// CavAi (Gen 1.0)
// Analytics + suggestion engine + site intelligence + head/eye/pupil tracking

(function () {
  /* eslint-disable @typescript-eslint/no-unused-vars */
  'use strict';

 // ===== HARD GUARD: prevent double-loading (glitchy eyes = duplicate listeners / transform fights) =====
 if (typeof window !== 'undefined') {
   if (window.__cavaiGen1Loaded) return;
   window.__cavaiGen1Loaded = true;
 }

 // ===== Shared Utilities & Analytics (no network) =====

 function randomFrom(array) {
   if (!array || !array.length) return '';
   var idx = Math.floor(Math.random() * array.length);
   return array[idx];
 }

 function safeParseJSON(raw, fallback) {
   if (!raw) return fallback;
   try {
     var parsed = JSON.parse(raw);
     return (parsed && typeof parsed === 'object') ? parsed : fallback;
   } catch (e) {
     return fallback;
   }
 }

 var ANALYTICS_KEY = 'cavbotMetrics';
 var VISIT_KEY = 'cavbotVisitCount';
 var SESSION_KEY = 'cavbotSessionId';
 var EVENT_LOG_KEY = 'cavbotEventLogV1';

 function createSessionId() {
   return 'sess-' + Math.random().toString(36).slice(2) + Date.now().toString(36);
 }

 function getOrCreateSessionId() {
   try {
     var existing = window.sessionStorage.getItem(SESSION_KEY);
     if (existing) return existing;
     var fresh = createSessionId();
     window.sessionStorage.setItem(SESSION_KEY, fresh);
     return fresh;
   } catch (e) {
     // sessionStorage not available, fall back to ephemeral id
     return createSessionId();
   }
 }

 // Device-level analytics snapshot (local only)
 var analytics = {
   visitCount: 1,
   lifetimeCatches: 0,
   lifetimeMisses: 0,
   lifetimeRounds: 0,
   bestMs: null,
   bestRuns: [], // [{ ms, at }]
   lastVisit: null
 };

 // Session-level info (per browser session / tab)
 var session = {
   id: getOrCreateSessionId(),
   startedAt: new Date().toISOString(),
   catches: 0,
   misses: 0,
   rounds: 0,
   bestMs: null
 };

 function persistAnalytics() {
   try {
     window.localStorage.setItem(ANALYTICS_KEY, JSON.stringify(analytics));
   } catch (e) {
     // storage not available, fail silently
   }
 }

 function persistEventLog(events) {
   try {
     window.localStorage.setItem(EVENT_LOG_KEY, JSON.stringify(events));
   } catch (e) {
     // ignore
   }
 }

 function forwardToGlobalAnalytics(eventName, payload) {
   try {
     if (
       window.cavbotAnalytics &&
       typeof window.cavbotAnalytics.track === 'function'
     ) {
       window.cavbotAnalytics.track(eventName, payload);
     }
   } catch (e) {
     // never let analytics break anything
   }
 }

 function trackEvent(eventName, payload) {
   var evt = {
     name: eventName,
     ts: Date.now(),
     sessionId: session.id,
     path: (typeof window !== 'undefined' && window.location)
       ? window.location.pathname + window.location.search
       : '',
     referrer: (typeof document !== 'undefined') ? (document.referrer || '') : '',
     payload: payload || {}
   };

   // In-memory queue for quick access
   if (!trackEvent.queue) {
     trackEvent.queue = [];
   }
   trackEvent.queue.push(evt);
   if (trackEvent.queue.length > 80) {
     trackEvent.queue.shift();
   }

   // Compact local event log (device-local only)
   try {
     var existing = safeParseJSON(
       window.localStorage.getItem(EVENT_LOG_KEY),
       []
     ) || [];
     existing.push(evt);
     while (existing.length > 120) {
       existing.shift();
     }
     persistEventLog(existing);
   } catch (e) {
     // ignore storage issues
   }

   // Forward to global analytics runtime when you wire your backend
   forwardToGlobalAnalytics(eventName, evt);
 }

 // ===== CavBot Site Intelligence · Suggestion Engine (SEO / A11y / UX / Perf / Engagement) =====

 var SUGGESTION_SEVERITY_WEIGHT = {
   critical: 4,
   high: 3,
   medium: 2,
   low: 1,
   note: 0
 };

 function clampNumber(value, min, max) {
   if (typeof value !== 'number' || isNaN(value)) return min;
   if (value < min) return min;
   if (value > max) return max;
   return value;
 }

 function coerceScore(value, fallback) {
   if (typeof value === 'number' && !isNaN(value)) {
     return clampNumber(value, 0, 100);
   }
   return fallback;
 }

 function pushSuggestion(list, spec) {
   if (!list) return;
   var suggestion = {
     id: spec.id || null,
     category: spec.category || 'seo',
     severity: spec.severity || 'medium',
     message: spec.message || '',
     hint: spec.hint || '',
     metric: spec.metric || null,
     scoreImpact: typeof spec.scoreImpact === 'number' ? spec.scoreImpact : 0,
     context: spec.context || null
   };
   list.push(suggestion);
 }

 // --- SEO suggestions (on-page + structure) ---

 function buildSeoSuggestions(diag) {
   var suggestions = [];
   if (!diag || typeof diag !== 'object') return suggestions;

   if (!diag.hasTitle) {
     pushSuggestion(suggestions, {
       id: 'missing_title',
       category: 'seo',
       severity: 'high',
       message: 'Add a clear, unique <title> tag for this page.',
       hint: 'Aim for 45–60 characters that naturally include your primary keyword and feel human to read.',
       metric: 'title',
       scoreImpact: 8
     });
   }

   if (typeof diag.titleLength === 'number' && diag.hasTitle) {
     if (diag.titleLength < 25) {
       pushSuggestion(suggestions, {
         id: 'short_title',
         category: 'seo',
         severity: 'medium',
         message: 'Title is very short.',
         hint: 'Give search engines and users more context; aim for a descriptive, compelling title, not just 1–2 words.',
         metric: 'titleLength',
         scoreImpact: 3
       });
     } else if (diag.titleLength > 65) {
       pushSuggestion(suggestions, {
         id: 'long_title',
         category: 'seo',
         severity: 'medium',
         message: 'Title is likely to be truncated in search results.',
         hint: 'Keep titles within roughly 45–65 characters so the most important part remains visible.',
         metric: 'titleLength',
         scoreImpact: 3
       });
     }
   }

   if (!diag.hasMetaDescription) {
     pushSuggestion(suggestions, {
       id: 'missing_meta_description',
       category: 'seo',
       severity: 'high',
       message: 'Add a meta description.',
       hint: 'Write 140–160 characters that summarize the page and encourage clicks from search results.',
       metric: 'metaDescription',
       scoreImpact: 6
     });
   }

   if (typeof diag.metaDescriptionLength === 'number' && diag.hasMetaDescription) {
     if (diag.metaDescriptionLength < 80) {
       pushSuggestion(suggestions, {
         id: 'short_meta_description',
         category: 'seo',
         severity: 'medium',
         message: 'Meta description is quite short.',
         hint: 'Use the meta description to answer “Why should I click?” in 1–2 concise sentences.',
         metric: 'metaDescriptionLength',
         scoreImpact: 2
       });
     } else if (diag.metaDescriptionLength > 180) {
       pushSuggestion(suggestions, {
         id: 'long_meta_description',
         category: 'seo',
         severity: 'low',
         message: 'Meta description may be too long.',
         hint: 'Keep descriptions roughly in the 140–160 character range to avoid truncation.',
         metric: 'metaDescriptionLength',
         scoreImpact: 1
       });
     }
   }

   if (diag.indexable === false) {
     pushSuggestion(suggestions, {
       id: 'noindex',
       category: 'seo',
       severity: 'critical',
       message: 'This page is currently not indexable.',
       hint: 'Remove noindex from the robots meta or HTTP header if you want this page to appear in search.',
       metric: 'indexable',
       scoreImpact: 12
     });
   }

   if (diag.h1Count === 0) {
     pushSuggestion(suggestions, {
       id: 'missing_h1',
       category: 'seo',
       severity: 'medium',
       message: 'Add a primary H1 heading.',
       hint: 'Use a single H1 that clearly states the main topic of the page and matches search intent.',
       metric: 'h1Count',
       scoreImpact: 4
     });
   } else if (diag.h1Count > 1) {
     pushSuggestion(suggestions, {
       id: 'multiple_h1',
       category: 'seo',
       severity: 'medium',
       message: 'Multiple H1 headings detected.',
       hint: 'Limit each page to one H1 and use H2 / H3 to build a clear content hierarchy.',
       metric: 'h1Count',
       scoreImpact: 3
     });
   }

   if (typeof diag.wordCount === 'number' && diag.wordCount < 150) {
     pushSuggestion(suggestions, {
       id: 'thin_content',
       category: 'seo',
       severity: 'medium',
       message: 'Content is very thin.',
       hint: 'Expand the page with genuinely useful, descriptive content that answers the questions users bring.',
       metric: 'wordCount',
       scoreImpact: 4
     });
   }

   if (typeof diag.wordCount === 'number' && diag.wordCount >= 150 && diag.wordCount < 400) {
     pushSuggestion(suggestions, {
       id: 'light_content',
       category: 'seo',
       severity: 'low',
       message: 'Content is somewhat light.',
       hint: 'Consider adding a bit more depth—examples, FAQs, or supporting sections—to strengthen relevance.',
       metric: 'wordCount',
       scoreImpact: 2
     });
   }

   if (diag.imageCount > 0 && typeof diag.imagesMissingAlt === 'number') {
     var ratio = diag.imagesMissingAlt / diag.imageCount;
     if (ratio > 0.3) {
       pushSuggestion(suggestions, {
         id: 'missing_alt_text',
         category: 'seo',
         severity: 'medium',
         message: 'Many images are missing alt text.',
         hint: 'Add short, descriptive alt attributes so search engines and screen readers understand each image.',
         metric: 'imagesMissingAlt',
         scoreImpact: 4
       });
     }
   }

   if (!diag.hasViewport) {
     pushSuggestion(suggestions, {
       id: 'missing_viewport',
       category: 'seo',
       severity: 'medium',
       message: 'Missing responsive viewport meta tag.',
       hint: 'Add <meta name="viewport" content="width=device-width, initial-scale=1"> to improve mobile experience and SEO.',
       metric: 'viewport',
       scoreImpact: 3
     });
   }

   if (!diag.hasLang) {
     pushSuggestion(suggestions, {
       id: 'missing_lang',
       category: 'accessibility',
       severity: 'low',
       message: 'Missing lang attribute on <html>.',
       hint: 'Add lang="en" or the correct language code to help screen readers and search engines interpret the page.',
       metric: 'htmlLang',
       scoreImpact: 2
     });
   }

   if (!diag.hasOg || !diag.hasTwitter) {
     pushSuggestion(suggestions, {
       id: 'social_tags',
       category: 'seo',
       severity: 'low',
       message: 'Social sharing tags are incomplete.',
       hint: 'Add Open Graph and Twitter meta tags so links to this page render strong, branded previews.',
       metric: 'socialMeta',
       scoreImpact: 2
     });
   }

   // Advanced SEO structure / technical

   if (diag.hasCanonical === false) {
     pushSuggestion(suggestions, {
       id: 'missing_canonical',
       category: 'seo',
       severity: 'medium',
       message: 'No canonical URL specified for this page.',
       hint: 'Add a <link rel="canonical"> pointing to the preferred URL to consolidate ranking signals.',
       metric: 'canonical',
       scoreImpact: 3
     });
   }

   if (diag.canonicalConflict === true) {
     pushSuggestion(suggestions, {
       id: 'canonical_conflict',
       category: 'seo',
       severity: 'high',
       message: 'Canonical URL may conflict with the requested URL.',
       hint: 'Verify that the canonical points to the correct version of this content and that you’re not self-cannibalizing rankings.',
       metric: 'canonical',
       scoreImpact: 6
     });
   }

   if (typeof diag.urlLength === 'number' && diag.urlLength > 120) {
     pushSuggestion(suggestions, {
       id: 'long_url',
       category: 'seo',
       severity: 'low',
       message: 'URL path is very long.',
       hint: 'Shorten the URL where possible to keep it readable and shareable while retaining important keywords.',
       metric: 'urlLength',
       scoreImpact: 2
     });
   }

   if (typeof diag.urlDepth === 'number' && diag.urlDepth > 4) {
     pushSuggestion(suggestions, {
       id: 'deep_url',
       category: 'seo',
       severity: 'low',
       message: 'This URL is deeply nested.',
       hint: 'Consider simplifying your directory depth for better crawlability and a clearer information architecture.',
       metric: 'urlDepth',
       scoreImpact: 2
     });
   }

   if (typeof diag.internalLinkCount === 'number' && diag.internalLinkCount < 3) {
     pushSuggestion(suggestions, {
       id: 'few_internal_links',
       category: 'seo',
       severity: 'medium',
       message: 'Very few internal links point to or from this page.',
       hint: 'Add contextual internal links so this page is woven into your site structure and easier for crawlers and users to reach.',
       metric: 'internalLinkCount',
       scoreImpact: 4
     });
   }

   if (typeof diag.brokenLinkCount === 'number' && diag.brokenLinkCount > 0) {
     pushSuggestion(suggestions, {
       id: 'broken_links',
       category: 'seo',
       severity: diag.brokenLinkCount > 3 ? 'high' : 'medium',
       message: 'Broken links detected.',
       hint: 'Fix or remove broken internal and external links to avoid sending users into dead ends and wasting crawl budget.',
       metric: 'brokenLinkCount',
       scoreImpact: 5
     });
   }

   if (diag.duplicateTitle === true) {
     pushSuggestion(suggestions, {
       id: 'duplicate_title',
       category: 'seo',
       severity: 'medium',
       message: 'Page title appears to be duplicated on multiple URLs.',
       hint: 'Differentiate this page with a unique, intent-matched title to avoid internal competition in search.',
       metric: 'duplicateTitle',
       scoreImpact: 4
     });
   }

   if (diag.duplicateMetaDescription === true) {
     pushSuggestion(suggestions, {
       id: 'duplicate_meta_description',
       category: 'seo',
       severity: 'low',
       message: 'Meta description appears to be reused on other pages.',
       hint: 'Write a description that reflects the specific value of this page instead of reusing generic copy.',
       metric: 'duplicateMetaDescription',
       scoreImpact: 2
     });
   }

   if (diag.hasStructuredData === false && diag.contentType) {
     pushSuggestion(suggestions, {
       id: 'missing_structured_data',
       category: 'seo',
       severity: 'low',
       message: 'Structured data is missing for this content type.',
       hint: 'Consider adding schema.org structured data (e.g. Article, Product, LocalBusiness) to unlock richer search results.',
       metric: 'structuredData',
       scoreImpact: 3
     });
   }

   return suggestions;
 }

 // --- Accessibility suggestions ---

 function buildAccessibilitySuggestions(a11y) {
   var suggestions = [];
   if (!a11y || typeof a11y !== 'object') return suggestions;

   if (typeof a11y.colorContrastIssues === 'number' && a11y.colorContrastIssues > 0) {
     pushSuggestion(suggestions, {
       id: 'color_contrast',
       category: 'accessibility',
       severity: a11y.colorContrastIssues > 5 ? 'high' : 'medium',
       message: 'Color contrast issues detected.',
       hint: 'Increase contrast between text and background to meet WCAG guidelines, especially for body copy and buttons.',
       metric: 'colorContrastIssues',
       scoreImpact: 7
     });
   }

   if (typeof a11y.missingAlt === 'number' && a11y.missingAlt > 0) {
     pushSuggestion(suggestions, {
       id: 'a11y_missing_alt',
       category: 'accessibility',
       severity: 'medium',
       message: 'Images without alt text detected.',
       hint: 'Add meaningful alt attributes for images that convey information. Decorative images can use empty alt="" attributes.',
       metric: 'missingAlt',
       scoreImpact: 4
     });
   }

   if (typeof a11y.missingFormLabels === 'number' && a11y.missingFormLabels > 0) {
     pushSuggestion(suggestions, {
       id: 'missing_form_labels',
       category: 'accessibility',
       severity: 'high',
       message: 'Form inputs without labels detected.',
       hint: 'Associate every input with a visible <label> or ARIA label so assistive technologies can announce it properly.',
       metric: 'missingFormLabels',
       scoreImpact: 8
     });
   }

   if (typeof a11y.focusVisibleIssues === 'number' && a11y.focusVisibleIssues > 0) {
     pushSuggestion(suggestions, {
       id: 'focus_visible',
       category: 'accessibility',
       severity: 'medium',
       message: 'Keyboard focus states are difficult to see or missing.',
       hint: 'Ensure interactive elements have a clearly visible focus outline so keyboard users can track their position.',
       metric: 'focusVisibleIssues',
       scoreImpact: 5
     });
   }

   if (typeof a11y.keyboardTrapCount === 'number' && a11y.keyboardTrapCount > 0) {
     pushSuggestion(suggestions, {
       id: 'keyboard_trap',
       category: 'accessibility',
       severity: 'critical',
       message: 'Potential keyboard trap detected.',
       hint: 'Review dialogs/menus so keyboard users can both reach and exit them using Tab/Shift+Tab and Escape.',
       metric: 'keyboardTrapCount',
       scoreImpact: 12
     });
   }

   if (a11y.headingOrderIssues === true) {
     pushSuggestion(suggestions, {
       id: 'heading_order',
       category: 'accessibility',
       severity: 'medium',
       message: 'Heading levels may be out of logical order.',
       hint: 'Use headings in sequence (H1 → H2 → H3) to reflect the actual structure of the content.',
       metric: 'headingOrderIssues',
       scoreImpact: 4
     });
   }

   if (a11y.landmarkIssues === true) {
     pushSuggestion(suggestions, {
       id: 'landmarks',
       category: 'accessibility',
       severity: 'low',
       message: 'Landmark regions are incomplete or missing.',
       hint: 'Add ARIA landmarks (main, nav, header, footer) to help assistive tech users navigate by regions.',
       metric: 'landmarkIssues',
       scoreImpact: 2
     });
   }

   if (a11y.hasSkipLink === false) {
     pushSuggestion(suggestions, {
       id: 'skip_link',
       category: 'accessibility',
       severity: 'low',
       message: 'Skip-to-content link not detected.',
       hint: 'Consider adding a “Skip to main content” link at the top of the page for keyboard users.',
       metric: 'hasSkipLink',
       scoreImpact: 2
     });
   }

   if (a11y.prefersReducedMotionRespected === false) {
     pushSuggestion(suggestions, {
       id: 'reduced_motion',
       category: 'accessibility',
       severity: 'medium',
       message: 'Prefers-reduced-motion is not fully respected.',
       hint: 'Honor the prefers-reduced-motion media query by toning down or disabling large animations where possible.',
       metric: 'prefersReducedMotion',
       scoreImpact: 4
     });
   }

   return suggestions;
 }

 // --- Performance suggestions (runtime feel / loading) ---

 function buildPerformanceSuggestions(perf) {
   var suggestions = [];
   if (!perf || typeof perf !== 'object') return suggestions;

   if (typeof perf.lcpMs === 'number') {
     if (perf.lcpMs > 4000) {
       pushSuggestion(suggestions, {
         id: 'lcp_slow',
         category: 'performance',
         severity: 'high',
         message: 'Largest Contentful Paint (LCP) is slow.',
         hint: 'Optimize your hero image, critical CSS, and server response so the main content appears within ~2.5s.',
         metric: 'lcpMs',
         scoreImpact: 8
       });
     } else if (perf.lcpMs > 2500) {
       pushSuggestion(suggestions, {
         id: 'lcp_borderline',
         category: 'performance',
         severity: 'medium',
         message: 'Largest Contentful Paint could be faster.',
         hint: 'Audit above-the-fold content and defer non-critical scripts to bring LCP closer to 2.5s.',
         metric: 'lcpMs',
         scoreImpact: 4
       });
     }
   }

   if (typeof perf.cls === 'number' && perf.cls > 0.1) {
     pushSuggestion(suggestions, {
       id: 'cls_high',
       category: 'performance',
       severity: perf.cls > 0.25 ? 'high' : 'medium',
       message: 'Cumulative Layout Shift (CLS) is high.',
       hint: 'Reserve space for images and embeds, and avoid inserting content above existing content after load.',
       metric: 'cls',
       scoreImpact: 7
     });
   }

   if (typeof perf.totalBlockingTimeMs === 'number' && perf.totalBlockingTimeMs > 300) {
     pushSuggestion(suggestions, {
       id: 'tbt_high',
       category: 'performance',
       severity: 'high',
       message: 'Long tasks are blocking the main thread.',
       hint: 'Split heavy JavaScript into smaller chunks and defer non-critical work so the UI stays responsive.',
       metric: 'totalBlockingTimeMs',
       scoreImpact: 8
     });
   }

   if (typeof perf.javascriptBytesKb === 'number' && perf.javascriptBytesKb > 300) {
     pushSuggestion(suggestions, {
       id: 'js_bundle_size',
       category: 'performance',
       severity: 'medium',
       message: 'JavaScript bundle size is heavy.',
       hint: 'Remove unused libraries, tree-shake imports, and lazy-load routes to keep shipped JS lean.',
       metric: 'javascriptBytesKb',
       scoreImpact: 5
     });
   }

   if (typeof perf.imageBytesKb === 'number' && perf.imageBytesKb > 1000) {
     pushSuggestion(suggestions, {
       id: 'large_images',
       category: 'performance',
       severity: 'medium',
       message: 'Images contribute a lot of weight.',
       hint: 'Use modern formats (WebP/AVIF), compress images, and avoid sending full-resolution assets where not needed.',
       metric: 'imageBytesKb',
       scoreImpact: 5
     });
   }

   if (perf.usesLazyLoading === false && perf.imageCountAboveFold > 0) {
     pushSuggestion(suggestions, {
       id: 'lazy_loading',
       category: 'performance',
       severity: 'low',
       message: 'Images below the fold are not lazy-loaded.',
       hint: 'Enable loading="lazy" for non-critical images to delay their loading until needed.',
       metric: 'usesLazyLoading',
       scoreImpact: 3
     });
   }

   return suggestions;
 }

 // --- UX suggestions (layout, navigation, interaction) ---

 function buildUxSuggestions(ux) {
   var suggestions = [];
   if (!ux || typeof ux !== 'object') return suggestions;

   if (ux.navDepth && ux.navDepth > 3) {
     pushSuggestion(suggestions, {
       id: 'deep_navigation',
       category: 'ux',
       severity: 'medium',
       message: 'Navigation may feel deep or complex.',
       hint: 'Flatten key navigation paths so important pages are accessible within 1–2 clicks.',
       metric: 'navDepth',
       scoreImpact: 3
     });
   }

   if (ux.hasCompetingPrimaryButtons === true) {
     pushSuggestion(suggestions, {
       id: 'competing_ctas',
       category: 'ux',
       severity: 'medium',
       message: 'Multiple primary CTAs compete for attention.',
       hint: 'Choose a single primary action per view and downgrade others to secondary styles.',
       metric: 'hasCompetingPrimaryButtons',
       scoreImpact: 3
     });
   }

   if (ux.heroAboveFoldMessageWeak === true) {
     pushSuggestion(suggestions, {
       id: 'weak_hero_message',
       category: 'ux',
       severity: 'medium',
       message: 'Hero section may not clearly state what this page is about.',
       hint: 'Refine your main headline and subcopy so a new visitor understands the product within a few seconds.',
       metric: 'heroClarity',
       scoreImpact: 4
     });
   }

   if (ux.hasAutoPlayingMedia === true && ux.mutedByDefault === false) {
     pushSuggestion(suggestions, {
       id: 'autoplay_media',
       category: 'ux',
       severity: 'medium',
       message: 'Autoplaying media with sound can be disruptive.',
       hint: 'Avoid auto-playing audio; let users choose when to play and keep sound muted by default if autoplay is necessary.',
       metric: 'autoplayMedia',
       scoreImpact: 3
     });
   }

   if (ux.modalCountOnLoad && ux.modalCountOnLoad > 0) {
     pushSuggestion(suggestions, {
       id: 'onload_modals',
       category: 'ux',
       severity: ux.modalCountOnLoad > 1 ? 'medium' : 'low',
       message: 'Modals or popups appear immediately on page load.',
       hint: 'Consider showing modals after engagement (scroll, time on page) rather than blocking the initial experience.',
       metric: 'modalCountOnLoad',
       scoreImpact: 3
     });
   }

   return suggestions;
 }

 // --- Engagement suggestions (clicks, scroll, behavior) ---

 function buildEngagementSuggestions(eng) {
   var suggestions = [];
   if (!eng || typeof eng !== 'object') return suggestions;

   if (typeof eng.bounceRate === 'number' && eng.bounceRate > 0.6) {
     pushSuggestion(suggestions, {
       id: 'high_bounce',
       category: 'engagement',
       severity: 'medium',
       message: 'Bounce rate looks high.',
       hint: 'Check whether the page answers the query quickly, loads fast, and offers a clear next step above the fold.',
       metric: 'bounceRate',
       scoreImpact: 4
     });
   }

   if (typeof eng.avgScrollDepth === 'number' && eng.avgScrollDepth < 0.4) {
     pushSuggestion(suggestions, {
       id: 'shallow_scroll',
       category: 'engagement',
       severity: 'medium',
       message: 'Most users are not scrolling very far.',
       hint: 'Bring key content and CTAs higher on the page and reduce “hero-only” fluff that blocks progression.',
       metric: 'avgScrollDepth',
       scoreImpact: 3
     });
   }

   if (
     typeof eng.primaryCtaImpressions === 'number' &&
     eng.primaryCtaImpressions > 30 &&
     typeof eng.primaryCtaClicks === 'number'
   ) {
     var ctr = eng.primaryCtaClicks / Math.max(1, eng.primaryCtaImpressions);
     if (ctr < 0.05) {
       pushSuggestion(suggestions, {
         id: 'low_cta_ctr',
         category: 'engagement',
         severity: 'medium',
         message: 'Primary call-to-action button has a low click-through rate.',
         hint: 'Experiment with clearer copy (e.g. “Start free trial” instead of “Learn more”), stronger contrast, and positioning above the fold.',
         metric: 'primaryCtaCtr',
         scoreImpact: 4,
         context: { ctr: ctr }
       });
     }
   }

   if (typeof eng.returnVisitorShare === 'number' && eng.returnVisitorShare < 0.1) {
     pushSuggestion(suggestions, {
       id: 'low_return_visitors',
       category: 'engagement',
       severity: 'low',
       message: 'Few visitors are coming back.',
       hint: 'Consider adding content worth returning for—blog posts, release notes, or resources—and simple ways to follow or subscribe.',
       metric: 'returnVisitorShare',
       scoreImpact: 2
     });
   }

   return suggestions;
 }

 // --- Aggregator + scoring + coach voice ---

 function buildCavbotSuggestions(snapshot) {
   snapshot = snapshot || {};
   var all = [];

   var seoSuggestions = buildSeoSuggestions(snapshot.seo);
   var a11ySuggestions = buildAccessibilitySuggestions(snapshot.accessibility);
   var perfSuggestions = buildPerformanceSuggestions(snapshot.performance);
   var uxSuggestions = buildUxSuggestions(snapshot.ux);
   var engagementSuggestions = buildEngagementSuggestions(snapshot.engagement);

   Array.prototype.push.apply(all, seoSuggestions);
   Array.prototype.push.apply(all, a11ySuggestions);
   Array.prototype.push.apply(all, perfSuggestions);
   Array.prototype.push.apply(all, uxSuggestions);
   Array.prototype.push.apply(all, engagementSuggestions);

   // Sort by severity (critical → low), then category
   all.sort(function (a, b) {
     var wa = SUGGESTION_SEVERITY_WEIGHT[a.severity] || 0;
     var wb = SUGGESTION_SEVERITY_WEIGHT[b.severity] || 0;
     if (wa !== wb) return wb - wa;
     if (a.category < b.category) return -1;
     if (a.category > b.category) return 1;
     return 0;
   });

   return all;
 }

 function computeHealthScores(snapshot) {
   snapshot = snapshot || {};
   var seoScore = coerceScore(snapshot.seo && snapshot.seo.seoScore, 80);
   var perfScore = coerceScore(
     snapshot.performance &&
     (snapshot.performance.perfScore || snapshot.performance.runtimeFeelScore),
     80
   );
   var a11yScore = coerceScore(
     snapshot.accessibility && snapshot.accessibility.accessibilityScore,
     80
   );
   var uxScore = coerceScore(snapshot.ux && snapshot.ux.uxScore, 80);
   var engagementScore = coerceScore(
     snapshot.engagement && snapshot.engagement.engagementScore,
     80
   );

   var weights = {
     seo: 0.35,
     performance: 0.20,
     accessibility: 0.20,
     ux: 0.15,
     engagement: 0.10
   };

   var overall = Math.round(
     seoScore * weights.seo +
     perfScore * weights.performance +
     a11yScore * weights.accessibility +
     uxScore * weights.ux +
     engagementScore * weights.engagement
   );

   return {
     overall: clampNumber(overall, 0, 100),
     seo: seoScore,
     performance: perfScore,
     accessibility: a11yScore,
     ux: uxScore,
     engagement: engagementScore
   };
 }

 function buildCoachMessage(snapshot) {
   var suggestions = buildCavbotSuggestions(snapshot || {});
   var scores = computeHealthScores(snapshot || {});

   if (!suggestions.length) {
     return 'System check: this page looks healthy. No high-severity issues detected. Keep an eye on performance and accessibility as you ship new changes.';
   }

   var countsBySeverity = {
     critical: 0,
     high: 0,
     medium: 0,
     low: 0,
     note: 0
   };
   var countsByCategory = {};

   suggestions.forEach(function (s) {
     if (countsBySeverity[s.severity] != null) {
       countsBySeverity[s.severity] += 1;
     }
     var cat = s.category || 'other';
     countsByCategory[cat] = (countsByCategory[cat] || 0) + 1;
   });

   var topCategories = Object.keys(countsByCategory)
     .sort(function (a, b) {
       return countsByCategory[b] - countsByCategory[a];
     })
     .slice(0, 2);

   var totalCritical = countsBySeverity.critical;
   var totalHigh = countsBySeverity.high;
   var totalMedium = countsBySeverity.medium;

   var line1 = 'Health snapshot · overall ' + scores.overall + '/100.';
   var line2 = '';
   var line3 = '';

   if (totalCritical + totalHigh > 0) {
     line2 =
       'I’m seeing ' +
       (totalCritical > 0 ? totalCritical + ' critical ' : '') +
       (totalCritical > 0 && totalHigh > 0 ? 'and ' : '') +
       (totalHigh > 0 ? totalHigh + ' high-severity ' : '') +
       'items to fix first.';
   } else if (totalMedium > 0) {
     line2 =
       'Most issues here are medium impact. Cleaning them up will steadily push this page into the 90s.';
   } else {
     line2 =
       'Remaining issues are mostly low impact—good candidates to refine once core features are stable.';
   }

   if (topCategories.length) {
     line3 =
       'Biggest leverage right now is in ' +
       topCategories.join(' & ') +
       '. Start there, then fine-tune the rest.';
   } else {
     line3 =
       'Tackle the highest severity items first, then iterate on the rest as you ship.';
   }

   return line1 + ' ' + line2 + ' ' + line3;
 }

 // --- Severity & category summaries (for Guardian / console) ---

 function buildSeveritySummaryFromSuggestions(suggestions) {
   var summary = {
     total: 0,
     bySeverity: {
       critical: 0,
       high: 0,
       medium: 0,
       low: 0,
       note: 0
     }
   };

   if (!Array.isArray(suggestions) || !suggestions.length) {
     return summary;
   }

   summary.total = suggestions.length;

   suggestions.forEach(function (s) {
     var sev = s.severity || 'note';
     if (summary.bySeverity[sev] == null) {
       summary.bySeverity[sev] = 0;
     }
     summary.bySeverity[sev] += 1;
   });

   return summary;
 }

 function buildCategorySummaryFromSuggestions(suggestions) {
   if (!Array.isArray(suggestions) || !suggestions.length) {
     return [];
   }

   var map = {};

   suggestions.forEach(function (s) {
     var cat = s.category || 'other';
     if (!map[cat]) {
       map[cat] = {
         category: cat,
         count: 0,
         bySeverity: {
           critical: 0,
           high: 0,
           medium: 0,
           low: 0,
           note: 0
         },
         topIds: []
       };
     }
     var bucket = map[cat];
     bucket.count += 1;
     var sev = s.severity || 'note';
     if (bucket.bySeverity[sev] == null) {
       bucket.bySeverity[sev] = 0;
     }
     bucket.bySeverity[sev] += 1;
     if (s.id && bucket.topIds.length < 5) {
       bucket.topIds.push(s.id);
     }
   });

   var list = Object.keys(map).map(function (key) {
     return map[key];
   });

   list.sort(function (a, b) {
     return b.count - a.count;
   });

   return list;
 }

 function labelForScore(score) {
   score = typeof score === 'number' ? score : 0;
   if (score >= 90) return 'Excellent';
   if (score >= 80) return 'Strong';
   if (score >= 65) return 'Stable';
   if (score >= 50) return 'Fragile';
   return 'At risk';
 }

 // explainScores(snapshot) – human-readable breakdown per pillar
 function explainScoresInternal(snapshot) {
   snapshot = snapshot || {};
   var scores = computeHealthScores(snapshot);
   var suggestions = buildCavbotSuggestions(snapshot);
   var severitySummary = buildSeveritySummaryFromSuggestions(suggestions);
   var categorySummary = buildCategorySummaryFromSuggestions(suggestions);

   function pillarInfo(pillarKey, humanLabel, categoryKey) {
     var score = scores[pillarKey];
     var scoreLabel = labelForScore(score);
     var cat = categoryKey || pillarKey;
     var catSuggestions = suggestions.filter(function (s) {
       return s.category === cat;
     });
     var catSeverity = buildSeveritySummaryFromSuggestions(catSuggestions);
     var explanation;

     if (!catSuggestions.length) {
       explanation =
         'No ' + humanLabel.toLowerCase() + '-specific issues detected in this snapshot.';
     } else {
       var majorParts = [];
       if (catSeverity.bySeverity.critical) {
         majorParts.push(catSeverity.bySeverity.critical + ' critical');
       }
       if (catSeverity.bySeverity.high) {
         majorParts.push(catSeverity.bySeverity.high + ' high');
       }
       if (!catSeverity.bySeverity.critical &&
         !catSeverity.bySeverity.high &&
         catSeverity.bySeverity.medium) {
         majorParts.push(catSeverity.bySeverity.medium + ' medium');
       }

       var issuePhrase;
       if (majorParts.length) {
         issuePhrase = majorParts.join(' and ') + ' issues to address.';
       } else {
         issuePhrase = catSeverity.total + ' low-impact issues to refine.';
       }

       var topMsg = '';
       if (catSuggestions[0] && catSuggestions[0].message) {
         topMsg = ' Focus first on: ' + catSuggestions[0].message;
       }

       explanation =
         humanLabel + ' is ' + scoreLabel.toLowerCase() + ' at ' + score +
         '/100. ' + issuePhrase + topMsg;
     }

     return {
       score: score,
       label: scoreLabel,
       issues: catSeverity.total,
       explanation: explanation
     };
   }

   var overallExplanation = (function () {
     var overallLabel = labelForScore(scores.overall);
     if (!suggestions.length) {
       return 'Overall health is ' + overallLabel.toLowerCase() +
         ' with no blocking issues in this snapshot.';
     }
     var topCats = categorySummary.slice(0, 2).map(function (c) { return c.category; });
     var catPhrase = topCats.length
       ? ' Biggest leverage is in ' + topCats.join(' & ') + '.'
       : '';
     return 'Overall health is ' + overallLabel.toLowerCase() +
       ' at ' + scores.overall + '/100 with ' + severitySummary.total +
       ' items flagged across all pillars.' + catPhrase;
   })();

   return {
     scores: scores,
     overall: {
       score: scores.overall,
       label: labelForScore(scores.overall),
       issues: severitySummary.total,
       explanation: overallExplanation
     },
     seo: pillarInfo('seo', 'SEO', 'seo'),
     performance: pillarInfo('performance', 'Performance', 'performance'),
     accessibility: pillarInfo('accessibility', 'Accessibility', 'accessibility'),
     ux: pillarInfo('ux', 'UX', 'ux'),
     engagement: pillarInfo('engagement', 'Engagement', 'engagement'),
     severitySummary: severitySummary,
     categorySummary: categorySummary
   };
 }

 // summarize(snapshot) – single call for Guardian / console
 function summarizeInternal(snapshot) {
   snapshot = snapshot || {};
   var scores = computeHealthScores(snapshot);
   var suggestions = buildCavbotSuggestions(snapshot);
   var coachMessage = buildCoachMessage(snapshot);
   var severitySummary = buildSeveritySummaryFromSuggestions(suggestions);
   var categorySummary = buildCategorySummaryFromSuggestions(suggestions);

   return {
     scores: scores,
     suggestions: suggestions,
     coachMessage: coachMessage,
     severitySummary: severitySummary,
     categorySummary: categorySummary
   };
 }

 // ===== Init core visit analytics =====

 (function initAnalytics() {
   // Guard for non-browser environments
   if (typeof window === 'undefined' || !window.localStorage) {
     return;
   }

   try {
     // Legacy visit count key
     var rawVisits = window.localStorage.getItem(VISIT_KEY);
     var prevVisits = rawVisits ? parseInt(rawVisits, 10) : 0;
     analytics.visitCount = Number.isNaN(prevVisits) ? 1 : prevVisits + 1;
     window.localStorage.setItem(VISIT_KEY, String(analytics.visitCount));

     // New metrics key
     var rawMetrics = window.localStorage.getItem(ANALYTICS_KEY);
     var parsed = safeParseJSON(rawMetrics, null);
     if (parsed) {
       if (typeof parsed.lifetimeCatches === 'number') {
         analytics.lifetimeCatches = parsed.lifetimeCatches;
       }
       if (typeof parsed.lifetimeMisses === 'number') {
         analytics.lifetimeMisses = parsed.lifetimeMisses;
       }
       if (typeof parsed.lifetimeRounds === 'number') {
         analytics.lifetimeRounds = parsed.lifetimeRounds;
       }
       if (typeof parsed.bestMs === 'number') {
         analytics.bestMs = parsed.bestMs;
       }
       if (typeof parsed.lastVisit === 'string') {
         analytics.lastVisit = parsed.lastVisit;
       }
       if (Array.isArray(parsed.bestRuns)) {
         analytics.bestRuns = parsed.bestRuns.slice(0, 5);
       }
     }

     analytics.lastVisit = new Date().toISOString();
     persistAnalytics();

     trackEvent('cavbot_control_room_visit', {
       visitCount: analytics.visitCount,
       lifetimeCatches: analytics.lifetimeCatches,
       lifetimeMisses: analytics.lifetimeMisses,
       lifetimeRounds: analytics.lifetimeRounds,
       bestMs: analytics.bestMs
     });
   } catch (e) {
     // localStorage not available, run with in-memory values
   }
 })();

// ===== CavBot Head, Eye & Pupil Tracking (Gen 1.0) =====

var headTrackingInitialized = false;

function collectCavbotHeadElements() {
  if (typeof document === 'undefined') return [];
  var nodes = [];
  var rawHeads = document.querySelectorAll('[data-cavbot-head]');
  var rawDmHeads = document.querySelectorAll('.cavbot-dm-avatar');
  var i;
  if (rawHeads && rawHeads.length) {
    for (i = 0; i < rawHeads.length; i++) {
      nodes.push(rawHeads[i]);
    }
  }
  if (rawDmHeads && rawDmHeads.length) {
    for (i = 0; i < rawDmHeads.length; i++) {
      nodes.push(rawDmHeads[i]);
    }
  }
  return nodes;
}

function buildCavbotHeadRecords(headNodes) {
  var heads = [];
  if (!headNodes || !headNodes.length || typeof window === 'undefined') {
    return heads;
  }
  for (var i = 0; i < headNodes.length; i++) {
    var headEl = headNodes[i];
    var cs = window.getComputedStyle(headEl);
    var baseTransform = cs && cs.transform && cs.transform !== 'none' ? cs.transform : '';

    var eyeNodes = headEl.querySelectorAll(
      '[data-cavbot-eye], .cavbot-eye, .cavbot-dm-eye'
    );
    var eyes = [];
    for (var j = 0; j < eyeNodes.length; j++) {
      var eyeEl = eyeNodes[j];
      var ecs = window.getComputedStyle(eyeEl);
      var eyeBase = ecs && ecs.transform && ecs.transform !== 'none' ? ecs.transform : '';

      var pupilNodes = eyeEl.querySelectorAll(
        '.cavbot-eye-pupil, [data-cavbot-pupil], .cavbot-dm-eye-pupil'
      );
      var pupils = [];
      for (var k = 0; k < pupilNodes.length; k++) {
        var pupilEl = pupilNodes[k];
        try {
          pupilEl.setAttribute('data-cavbot-pupil-managed', '1');
        } catch (e) {}
        var pcs = window.getComputedStyle(pupilEl);
        var pupilBase = pcs && pcs.transform && pcs.transform !== 'none' ? pcs.transform : '';
        pupils.push({
          el: pupilEl,
          baseTransform: pupilBase
        });
      }

      eyes.push({
        el: eyeEl,
        baseTransform: eyeBase,
        pupils: pupils
      });
    }

    heads.push({
      el: headEl,
      baseTransform: baseTransform,
      eyes: eyes
    });
  }
  return heads;
}

 function onReady(fn) {
   if (!fn || typeof fn !== 'function') return;
   if (typeof document === 'undefined') return;
   if (document.readyState === 'loading') {
     document.addEventListener('DOMContentLoaded', fn);
   } else {
     fn();
   }
 }

 function initCavbotHeadTracking() {
   if (typeof window === 'undefined' || typeof document === 'undefined') {
     return;
   }

   // respect prefers-reduced-motion
   var mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
   if (mq && mq.matches) {
     return;
   }

  // ----- UPDATED: include DM badge as heads -----
  var headNodes = collectCavbotHeadElements();
  if (!headNodes.length) {
    return;
  }

  var heads = buildCavbotHeadRecords(headNodes);
  if (!heads.length) {
    return;
  }

  var vw = Math.max(window.innerWidth || 1, 1);
  var vh = Math.max(window.innerHeight || 1, 1);
  var pointer = { x: 0.5, y: 0.45 }; // slight upward idle
  var POINTER_X_MARGIN = 0.15;
  var POINTER_Y_MARGIN = 0.2;
   var rafId = null;

   function updatePointer(evtLike) {
    var rawX = evtLike && typeof evtLike.clientX === 'number'
      ? evtLike.clientX / vw
      : 0.5;
    var rawY = evtLike && typeof evtLike.clientY === 'number'
      ? evtLike.clientY / vh
      : 0.45;

    pointer.x = rawX < POINTER_X_MARGIN
      ? POINTER_X_MARGIN
      : rawX > 1 - POINTER_X_MARGIN
        ? 1 - POINTER_X_MARGIN
        : rawX;
    pointer.y = rawY < POINTER_Y_MARGIN
      ? POINTER_Y_MARGIN
      : rawY > 1 - POINTER_Y_MARGIN
        ? 1 - POINTER_Y_MARGIN
        : rawY;

    queueFrame();
  }

  function queueFrame() {
    if (rafId != null) return;
    rafId = window.requestAnimationFrame(applyTransforms);
  }

  function refreshHeadRecords() {
    var updated = buildCavbotHeadRecords(collectCavbotHeadElements());
    if (!updated.length) return;
    heads.length = 0;
    for (var r = 0; r < updated.length; r++) {
      heads.push(updated[r]);
    }
    queueFrame();
    if (typeof window !== 'undefined') {
      window.__cavbotHeadTrackingLastRefresh = Date.now();
      window.__cavbotHeadTrackingHeadCount = heads.length;
    }
  }

   function applyTransforms() {
     rafId = null;

     // Normalized pointer (-1 → 1)
     var normX = (pointer.x - 0.5) * 2;
     var normY = (pointer.y - 0.5) * 2;

     // Pupil behavior (matches your local rolling script)
     var pupilMaxOffset = 6;
     var pupilX = normX * pupilMaxOffset;
     if (pupilX < -4) pupilX = -4;
     var pupilY = normY * pupilMaxOffset;

     for (var h = 0; h < heads.length; h++) {
       var head = heads[h];
       var headEl = head.el;

       var strengthAttr = headEl.getAttribute('data-cavbot-tilt') || '1';
       var strength = parseFloat(strengthAttr);
       if (!isFinite(strength) || strength <= 0) strength = 1;

       // ----- UPDATED: DM badge = eyes only, no head tilt -----
       var isDm = headEl.className &&
         headEl.className.indexOf('cavbot-dm-avatar') !== -1;

       var headStrength = isDm ? 0 : strength; // keep DM badge fixed
       var eyeStrength = isDm ? 1 : strength;  // but still move its eyes
       // -------------------------------------------------------

       // HEAD: broader, heavier motion
       var maxTranslate = 10 * headStrength;
       var maxTilt = 10 * headStrength;

       var tx = normX * maxTranslate;
       var ty = normY * maxTranslate * -0.6;
       var rotY = normX * maxTilt;
       var rotX = normY * -maxTilt * 0.8;

       var composite =
         'translate3d(' + tx.toFixed(2) + 'px,' + ty.toFixed(2) + 'px,0) ' +
         'rotateX(' + rotX.toFixed(2) + 'deg) ' +
         'rotateY(' + rotY.toFixed(2) + 'deg)';

       if (head.baseTransform && head.baseTransform !== 'none') {
         composite += ' ' + head.baseTransform;
       }

       headEl.style.transform = composite;

       // EYES: subtle socket movement
       if (head.eyes && head.eyes.length) {
         var eyeTx = normX * 6 * eyeStrength;
         var eyeTy = normY * 4 * eyeStrength;

         for (var e = 0; e < head.eyes.length; e++) {
           var eye = head.eyes[e];

           // Eye container
           var eyeComposite =
             'translate3d(' + eyeTx.toFixed(2) + 'px,' + eyeTy.toFixed(2) + 'px,0)';
           if (eye.baseTransform && eye.baseTransform !== 'none') {
             eyeComposite += ' ' + eye.baseTransform;
           }
           eye.el.style.transform = eyeComposite;

           // Pupils: pure 2D translate, same feel as your snippet
           if (eye.pupils && eye.pupils.length) {
             for (var p = 0; p < eye.pupils.length; p++) {
               var pupil = eye.pupils[p];
               var pupilComposite =
                 'translate(' + pupilX.toFixed(2) + 'px,' + pupilY.toFixed(2) + 'px)';
               if (pupil.baseTransform && pupil.baseTransform !== 'none') {
                 pupilComposite += ' ' + pupil.baseTransform;
               }
               pupil.el.style.transform = pupilComposite;
             }
           }
         }
       }
     }
   }

   function handleMouseMove(evt) {
     updatePointer(evt);
   }

   function handleTouchMove(evt) {
     if (!evt.touches || !evt.touches.length) return;
     updatePointer(evt.touches[0]);
   }

   window.addEventListener('mousemove', handleMouseMove, { passive: true });
   window.addEventListener('touchmove', handleTouchMove, { passive: true });
   window.addEventListener('resize', function () {
     vw = Math.max(window.innerWidth || 1, 1);
     vh = Math.max(window.innerHeight || 1, 1);
   });

  // initial idle pose
  queueFrame();

  if (typeof window !== 'undefined') {
    window.__cavbotHeadTrackingReady = true;
    window.__cavbotHeadTrackingHeadCount = heads.length;
    window.__cavbotHeadTrackingLastRefresh = Date.now();
    window.__cavaiHeadTrackingRefresh = refreshHeadRecords;
  }

   try {
      trackEvent('cavbot_head_tracking_enabled', {
        headCount: heads.length
      });
    } catch (e) {
      // analytics is a nice-to-have
    }
    emitEvent('head_tracking_enabled', { headCount: heads.length });
  }

 function ensureHeadTracking() {
   if (headTrackingInitialized) return;
   headTrackingInitialized = true;

   // Global data-cavbot-head tracking (heads, eyes, pupils)
   initCavbotHeadTracking();

   // About-page full-body orbit bot tracking (cavbot-shell / cavbot-head / cavbot-eye-pupil)
   initCavbotBodyOrbitTracking();
 }

 // ===== CavBot Full-Body Orbit Head + Eye Tracking (about page) =====

 function initCavbotBodyOrbitTracking() {
   if (typeof window === 'undefined' || typeof document === 'undefined') {
     return;
   }

   // respect prefers-reduced-motion
   var mq = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)');
   if (mq && mq.matches) {
     return;
   }

   // This is the about-page full body bot orbit container
   var shell = document.querySelector('.about-hero-bot-orbit .cavbot-shell');
   if (!shell) return;

   var head = shell.querySelector('.cavbot-head');
   var pupils = shell.querySelectorAll('.cavbot-eye-pupil');

   if (!head || !pupils.length) return;

   var targetX = 0;
   var targetY = 0;
   var currentX = 0;
   var currentY = 0;
   var ticking = false;

   function applyMotion() {
     ticking = false;

     // ease towards target
     currentX += (targetX - currentX) * 0.18;
     currentY += (targetY - currentY) * 0.18;

     var headTranslateX = currentX * 6; // px
     var headTranslateY = currentY * 4;

     head.style.transform = 'translate(' + headTranslateX + 'px,' + headTranslateY + 'px)';

     var eyeShiftX = currentX * 10;
     var eyeShiftY = currentY * 8;

     // move pupils
     for (var i = 0; i < pupils.length; i++) {
       var pupil = pupils[i];
       pupil.style.transform = 'translate(' + eyeShiftX + 'px,' + eyeShiftY + 'px)';
     }

     // keep easing until very close
     if (Math.abs(targetX - currentX) > 0.001 || Math.abs(targetY - currentY) > 0.001) {
       ticking = true;
       window.requestAnimationFrame(applyMotion);
     }
   }

   function onPointerMove(evt) {
     var rect = shell.getBoundingClientRect();
     if (!rect || !rect.width || !rect.height) return;

     var x = (evt.clientX - rect.left) / rect.width - 0.5; // -0.5 .. 0.5
     var y = (evt.clientY - rect.top) / rect.height - 0.5;

     // clamp
     if (x < -0.5) x = -0.5;
     if (x >  0.5) x =  0.5;
     if (y < -0.5) y = -0.5;
     if (y >  0.5) y =  0.5;

     targetX = x;
     targetY = y;

     if (!ticking) {
       ticking = true;
       window.requestAnimationFrame(applyMotion);
     }
   }

   function resetMotion() {
     targetX = 0;
     targetY = 0;
     if (!ticking) {
       ticking = true;
       window.requestAnimationFrame(applyMotion);
     }
   }

   // Global pointer tracking, motion is localized to the shell via its rect
   window.addEventListener('pointermove', onPointerMove);
   window.addEventListener('pointerleave', resetMotion);

   // start from neutral pose
   resetMotion();
 }

 // auto-init when DOM is ready
 onReady(ensureHeadTracking);

 // ===== Public brain API for other pages / future backend & console =====

 try {
   window.cavai = window.cavai || {};

   window.cavai.getSnapshot = function () {
     return {
       analytics: Object.assign({}, analytics),
       session: Object.assign({}, session),
       recentEvents: (trackEvent.queue || []).slice(-40)
     };
   };

   window.cavai.getSessionId = function () {
     return session.id;
   };

   window.cavai.getDeviceRecords = function () {
     return {
       bestMs: analytics.bestMs,
       bestRuns: analytics.bestRuns.slice()
     };
   };

   // Full suggestion + scoring API
   window.cavai.buildSuggestions = function (snapshot) {
     return buildCavbotSuggestions(snapshot || {});
   };

   window.cavai.getHealthScores = function (snapshot) {
     return computeHealthScores(snapshot || {});
   };

   window.cavai.getCoachMessage = function (snapshot) {
     return buildCoachMessage(snapshot || {});
   };

   window.cavai.trackSiteSnapshot = function (snapshot, context) {
     snapshot = snapshot || {};
     var scores = computeHealthScores(snapshot);
     var suggestions = buildCavbotSuggestions(snapshot);

     trackEvent('cavbot_site_snapshot', {
       scores: scores,
       suggestions: suggestions,
       snapshot: snapshot,
       context: context || {}
     });

     return {
       scores: scores,
       suggestions: suggestions
     };
   };

   // New: explainScores(snapshot) – human-readable breakdown per pillar
   window.cavai.explainScores = function (snapshot) {
     return explainScoresInternal(snapshot || {});
   };

   // New: summarize(snapshot) – clutch helper for Guardian panel / console
    window.cavai.summarize = function (snapshot) {
      var context = (snapshot && snapshot.context) ? snapshot.context : buildContextSnapshot();
      var summary = summarizeInternal(snapshot || {});
      var originKey = resolveOriginKey(context);
      try {
        if (
          originKey &&
          window &&
          window.cavAI &&
          window.cavAI.memory &&
          typeof window.cavAI.memory.recordFromSummary === 'function'
        ) {
          window.cavAI.memory.recordFromSummary({
            origin: originKey,
            summary: summary,
            context: context
          });
        }
      } catch (err) {
        // swallow recorder errors
      }
      return summary;
    };

   // New: utility summaries you can call directly if you already have suggestions
   window.cavai.getSeveritySummary = function (input) {
     var suggestions = Array.isArray(input)
       ? input
       : buildCavbotSuggestions(input || {});
     return buildSeveritySummaryFromSuggestions(suggestions);
   };

   window.cavai.getCategorySummary = function (input) {
     var suggestions = Array.isArray(input)
       ? input
       : buildCavbotSuggestions(input || {});
     return buildCategorySummaryFromSuggestions(suggestions);
   };

   // New: public event hook for non-game pages
   window.cavai.trackEvent = function (eventName, payload) {
     trackEvent(eventName, payload);
   };

   // New: public switch to (re)enable head / eye tracking on demand
   window.cavai.enableHeadTracking = function () {
     onReady(ensureHeadTracking);
   };

   // Version flag for debugging (kept at 1.0 as requested)
   window.cavai.version = '1.0';

   // Internal bridge for game modules (404 arena / future games)
  window.cavai._internal = {
    analytics: analytics,
    session: session,
    persistAnalytics: persistAnalytics,
    trackEvent: trackEvent
  };
} catch (e) {
  // ignore if window not available
}

  // ===== CavAI — new companion layer (Gen 1.x) =====

  var CAVAI_DEFAULT_CONFIG = {
    diagnosticsEndpoint: '/api/cavai/diagnostics',
    fixEndpoint: '/api/cavai/fixes',
    timeoutMs: 10000,
    debounceMs: 520,
    geoTimeoutMs: 14000
  };

  var GEO_STORAGE_KEY = 'cb_cavai_geo_v1';

  var cavAIConfig = Object.assign({}, CAVAI_DEFAULT_CONFIG);

  var eventHandlers = {};

  var diagAbortController = null;
  var diagDebounceTimer = null;
  var diagPendingPayload = null;
  var diagPendingResolvers = [];
  var diagRequestId = 0;

  var privacyReasons = [];
  var MEMORY_STORAGE_KEY = 'cb_cavai_memory_v1';
  var MEMORY_VERSION = 1;
  var MEMORY_MAX_ORIGINS = 25;
  var MEMORY_MAX_RUNS = 12;
  var intentCallState = {};
  var DEBUG_STORAGE_KEY = 'cb_cavai_debug';
  var SOFT_BURST_SCAN_KEY = 'cb_cavai_scan_history_v1';
  var SOFT_BURST_WINDOW_MS = 10 * 60 * 1000;
  var SOFT_BURST_SCAN_LIMIT = 2;
  var SOFT_BURST_MESSAGE = 'Recent scan detected. Make changes first, then run again.';
  var scanHistoryCache = null;

  function isPrivacyGateActive() {
    if (!window || !window.document) return false;
    var doc = window.document.documentElement;
    if (doc) {
      var attr = doc.getAttribute('data-cavai-analytics');
      if (attr && attr.toLowerCase() === 'off') return true;
    }
    if (typeof navigator !== 'undefined') {
      var dnt = navigator.doNotTrack || navigator.msDoNotTrack || window.doNotTrack;
      if (dnt === '1' || dnt === 'yes') return true;
      if (navigator.gpc === '1') return true;
    }
    return false;
  }

  function updatePrivacyState() {
    var active = isPrivacyGateActive();
    privacyReasons = active ? ['privacy_gate_active'] : [];
    return active;
  }

  function canPersistScanHistory() {
    if (typeof window === 'undefined' || !window.localStorage) {
      return false;
    }
    return !updatePrivacyState();
  }

  function readScanHistory() {
    if (scanHistoryCache) {
      return scanHistoryCache;
    }
    var data = {};
    if (typeof window === 'undefined' || !window.localStorage) {
      scanHistoryCache = data;
      return data;
    }
    try {
      var raw = window.localStorage.getItem(SOFT_BURST_SCAN_KEY);
      var parsed = safeParseJSON(raw, null);
      if (parsed && typeof parsed === 'object') {
        data = parsed;
      }
    } catch (e) {
      // ignore
    }
    scanHistoryCache = data;
    return data;
  }

  function persistScanHistory(history) {
    scanHistoryCache = history || {};
    if (!canPersistScanHistory()) {
      return;
    }
    try {
      window.localStorage.setItem(SOFT_BURST_SCAN_KEY, JSON.stringify(history || {}));
    } catch (e) {
      // ignore
    }
  }

  function pruneScanEntries(entries, now) {
    var kept = [];
    if (!Array.isArray(entries)) {
      return kept;
    }
    for (var i = 0; i < entries.length; i++) {
      var ts = entries[i];
      if (typeof ts !== 'number') continue;
      if (now - ts <= SOFT_BURST_WINDOW_MS) {
        kept.push(ts);
      }
    }
    return kept;
  }

  function reserveSoftBurstSlot(origin) {
    if (!origin) {
      return { allowed: true };
    }
    var now = Date.now();
    var history = readScanHistory();
    var entries = history[origin] || [];
    entries = pruneScanEntries(entries, now);
    history[origin] = entries;
    if (entries.length >= SOFT_BURST_SCAN_LIMIT) {
      persistScanHistory(history);
      return { allowed: false };
    }
    entries.push(now);
    history[origin] = entries;
    persistScanHistory(history);
    return { allowed: true };
  }

  function emitEvent(eventName, payload) {
    if (!eventHandlers) return;
    var handlers = eventHandlers[eventName];
    if (!handlers || !handlers.length) return;
    for (var i = 0; i < handlers.length; i++) {
      try {
        handlers[i](payload);
      } catch (err) {
        // swallow handler errors
      }
    }
  }

  function onEvent(eventName, handler) {
    if (!eventHandlers[eventName]) {
      eventHandlers[eventName] = [];
    }
    eventHandlers[eventName].push(handler);
  }

  function offEvent(eventName, handler) {
    var handlers = eventHandlers[eventName];
    if (!handlers) return;
    for (var i = handlers.length - 1; i >= 0; i--) {
      if (handlers[i] === handler) {
        handlers.splice(i, 1);
      }
    }
  }

  function fetchWithTimeout(url, options, timeout) {
    return new Promise(function (resolve, reject) {
      if (typeof window === 'undefined' || typeof window.fetch !== 'function') {
        reject(new Error('fetch_unavailable'));
        return;
      }
      var timer = window.setTimeout(function () {
        reject(new Error('timeout'));
        if (options && options.signal && options.signal.abort) {
          options.signal.abort();
        }
      }, timeout || 0);
      window.fetch(url, options || {})
        .then(function (res) {
          window.clearTimeout(timer);
          resolve(res);
        })
        .catch(function (err) {
          window.clearTimeout(timer);
          reject(err);
        });
    });
  }

  function getWindowSiteOrigin() {
    if (typeof window === 'undefined') return '';
    var cavbot = window.__CAVBOT__ || {};
    if (typeof cavbot.siteOrigin === 'string' && cavbot.siteOrigin) {
      return cavbot.siteOrigin;
    }
    if (window.location && window.location.origin) {
      return window.location.origin;
    }
    return '';
  }

  function buildContextSnapshot() {
    var browserOrigin = window && window.location ? window.location.origin : '';
    var context = {
      origin: browserOrigin,
      siteOrigin: getWindowSiteOrigin(),
      path: window && window.location ? window.location.pathname : '',
      mode: 'browser',
      planTier: (window.cavai && window.cavai.planTier) || null,
      activeFile: getActiveFileFromUrl(),
      pagesScanned: null,
      pageLimit: null
    };
    return context;
  }

  function getActiveFileFromUrl() {
    if (typeof window === 'undefined' || !window.location) return null;
    var params = new URLSearchParams(window.location.search);
    var file = params.get('file');
    return file ? file : null;
  }

  function deriveNextActions(suggestions) {
    if (!Array.isArray(suggestions)) return [];
    var sorted = suggestions.slice().sort(function (a, b) {
      var weightA = SUGGESTION_SEVERITY_WEIGHT[a.severity] || 0;
      var weightB = SUGGESTION_SEVERITY_WEIGHT[b.severity] || 0;
      if (weightB !== weightA) return weightB - weightA;
      if (a.id && b.id) {
        return a.id < b.id ? -1 : a.id > b.id ? 1 : 0;
      }
      return 0;
    });
    var next = [];
    for (var i = 0; i < Math.min(3, sorted.length); i++) {
      var suggestion = sorted[i];
      if (!suggestion || !suggestion.id) continue;
      next.push({
        suggestionId: suggestion.id,
        title: suggestion.message,
        hint: suggestion.hint || '',
        priority: i + 1
      });
    }
    return next;
  }

  function buildGeoSnapshot() {
    if (typeof window === 'undefined') return {};
    var tz = '';
    if (window.Intl && window.Intl.DateTimeFormat) {
      try {
        tz = window.Intl.DateTimeFormat().resolvedOptions().timeZone || '';
      } catch (e) {
        tz = '';
      }
    }
    var locale = (navigator && navigator.language) ? navigator.language : '';
    var regionHint = '';
    if (locale && locale.indexOf('-') !== -1) {
      regionHint = locale.split('-').slice(1).join('-');
    }
    var snapshot = {
      tz: tz,
      locale: locale,
      regionHint: regionHint,
      updatedAt: Date.now()
    };
    return snapshot;
  }

  function readGeoFromStorage() {
    try {
      var raw = window.localStorage.getItem(GEO_STORAGE_KEY);
      var parsed = safeParseJSON(raw, null);
      if (parsed && typeof parsed === 'object') {
        return parsed;
      }
    } catch (e) {
      // ignore
    }
    return buildGeoSnapshot();
  }

  function persistGeoSnapshot(snapshot) {
    try {
      window.localStorage.setItem(GEO_STORAGE_KEY, JSON.stringify(snapshot));
    } catch (e) {
      // ignore storage issues
    }
  }

  var coarseGeoSnapshot = (typeof window !== 'undefined') ? readGeoFromStorage() : buildGeoSnapshot();

  function sanitizeCoords(lat, lon, precision) {
    var factor = precision || 0.2;
    var roundedLat = Math.round(lat / factor) * factor;
    var roundedLon = Math.round(lon / factor) * factor;
    return {
      lat: Number(roundedLat.toFixed(3)),
      lon: Number(roundedLon.toFixed(3))
    };
  }

  function requestGeoInternal(opts) {
    opts = opts || {};
    if (updatePrivacyState()) {
      emitEvent('geo_denied', { reason: 'privacy' });
      return Promise.resolve({ ok: false, reason: 'privacy_gate_active' });
    }

    if (typeof navigator === 'undefined' || !navigator.geolocation) {
      emitEvent('geo_unavailable', { reason: 'geolocation_missing' });
      return Promise.resolve({ ok: false, reason: 'geolocation_unavailable' });
    }

    return new Promise(function (resolve) {
      var timeout = opts.timeoutMs || cavAIConfig.geoTimeoutMs;
      var resolved = false;

      function cleanup() {
        resolved = true;
      }

      var timer = window.setTimeout(function () {
        if (resolved) return;
        cleanup();
        emitEvent('geo_unavailable', { reason: 'timeout' });
        resolve({ ok: false, reason: 'timeout' });
      }, timeout);

      navigator.geolocation.getCurrentPosition(function (position) {
        if (resolved) return;
        cleanup();
        window.clearTimeout(timer);
        var coords = position && position.coords;
        if (!coords) {
          emitEvent('geo_unavailable', { reason: 'empty' });
          resolve({ ok: false, reason: 'no_coords' });
          return;
        }
        var sanitized = sanitizeCoords(coords.latitude, coords.longitude, opts.precisionGrid || 0.3);
        var payload = {
          ok: true,
          geo: {
            ts: Date.now(),
            country: opts.country || '',
            region: opts.region || '',
            city: opts.city || '',
            coordinates: sanitized,
            accuracy: opts.precise ? 'precise' : 'coarse'
          }
        };
        emitEvent('geo_available', payload);
        resolve(payload);
      }, function (err) {
        if (resolved) return;
        cleanup();
        window.clearTimeout(timer);
        var reason = err && err.code ? 'error_' + err.code : 'permission_denied';
        emitEvent('geo_denied', { reason: reason });
        resolve({ ok: false, reason: reason });
      }, {
        timeout: timeout,
        maximumAge: opts.maximumAge || 600000,
        enableHighAccuracy: !!opts.precise
      });
    });
  }

  function scheduleDiagnosticsRequest(payload) {
    if (diagDebounceTimer) {
      window.clearTimeout(diagDebounceTimer);
      diagDebounceTimer = null;
    }

    diagPendingPayload = payload;
    return new Promise(function (resolve) {
      diagPendingResolvers.push(resolve);
      diagDebounceTimer = window.setTimeout(function () {
        diagDebounceTimer = null;
        internalDiagnosticsRequest(payload).then(function (result) {
          finishPendingResolvers(result);
        }).catch(function (err) {
          finishPendingResolvers({ ok: false, reason: err && err.message ? err.message : 'unknown' });
        });
      }, cavAIConfig.debounceMs);
    });
  }

  function finishPendingResolvers(result) {
    while (diagPendingResolvers.length) {
      var resolver = diagPendingResolvers.shift();
      try {
        resolver(result);
      } catch (e) {
        // ignore
      }
    }
  }

  function internalDiagnosticsRequest(payload) {
    diagRequestId += 1;
    var requestId = diagRequestId;

    if (updatePrivacyState()) {
      var privacyResult = { ok: false, reason: 'privacy_gate_active' };
      emitEvent('diagnostics_failed', { requestId: requestId, reason: privacyResult.reason });
      return Promise.resolve(privacyResult);
    }

    if (window && window.fetch) {
      if (diagAbortController) {
        try {
          diagAbortController.abort();
        } catch (e) {}
      }
      diagAbortController = new AbortController();
    }

    var context = buildContextSnapshot();
    var payloadBody = payload || {};
    payloadBody.context = payloadBody.context || context;

    var emitPayload = {
      requestId: requestId,
      payload: payloadBody
    };
    emitEvent('diagnostics_requested', emitPayload);

    var options = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payloadBody),
      signal: diagAbortController ? diagAbortController.signal : undefined,
      credentials: 'same-origin'
    };

    return fetchWithTimeout(cavAIConfig.diagnosticsEndpoint, options, cavAIConfig.timeoutMs)
      .then(function (res) {
        if (!res || !res.ok) {
          throw new Error('diagnostics_failed');
        }
        return res.json && res.json();
      })
      .then(function (json) {
        emitEvent('diagnostics_received', { requestId: requestId, result: json });
        return { ok: true, data: json };
      })
      .catch(function (err) {
        var reason = err && err.message ? err.message : 'unknown';
        emitEvent('diagnostics_failed', { requestId: requestId, reason: reason });
        return { ok: false, reason: reason };
      });
  }

  function requestFixDiff(payload) {
    payload = payload || {};
    if (updatePrivacyState()) {
      emitEvent('diagnostics_failed', { reason: 'privacy_gate_active' });
      return Promise.resolve({ ok: false, reason: 'privacy_gate_active' });
    }
    if (!window || !window.fetch) {
      return Promise.resolve({ ok: false, reason: 'fetch_unavailable' });
    }
    var options = {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      credentials: 'same-origin'
    };
    emitEvent('diagnostics_requested', { payload: payload, type: 'fix' });
    return fetchWithTimeout(cavAIConfig.fixEndpoint, options, cavAIConfig.timeoutMs)
      .then(function (res) {
        if (!res || !res.ok) throw new Error('fix_failed');
        return res.json && res.json();
      })
      .then(function (json) {
        emitEvent('diagnostics_received', { payload: payload, type: 'fix', result: json });
        return { ok: true, data: json };
      })
      .catch(function (err) {
        var reason = err && err.message ? err.message : 'unknown';
        emitEvent('diagnostics_failed', { payload: payload, type: 'fix', reason: reason });
        return { ok: false, reason: reason };
      });
  }

  function buildSuggestionPack(snapshot, context) {
    snapshot = snapshot || {};
    var suggestions = buildCavbotSuggestions(snapshot);
    var keySignals = buildKeySignalsFromSuggestions(suggestions);
    var scores = computeHealthScores(snapshot);
    var coach = buildCoachMessage(snapshot);
    var severitySummary = buildSeveritySummaryFromSuggestions(suggestions);
    var categorySummary = buildCategorySummaryFromSuggestions(suggestions);
    var nextActions = deriveNextActions(suggestions);
    emitEvent('suggestion_pack_generated', {
      snapshot: snapshot,
      context: context || {},
      suggestions: suggestions,
      scores: scores
    });
    return {
      scores: scores,
      suggestions: suggestions,
      coachMessage: coach,
      severitySummary: severitySummary,
      categorySummary: categorySummary,
      keySignals: keySignals,
      nextActions: nextActions
    };
  }

  function buildCavAIStatus() {
    var privacyActive = updatePrivacyState();
    return {
      ready: true,
      mode: 'browser',
      privacy: privacyActive ? 'restricted' : 'open',
      contextComplete: true,
      reasons: privacyReasons.slice()
    };
  }

  function resolveOriginKey(context) {
    if (context && typeof context.siteOrigin === 'string' && context.siteOrigin) {
      return context.siteOrigin;
    }
    if (context && typeof context.origin === 'string' && context.origin) {
      return context.origin;
    }
    return getWindowSiteOrigin();
  }

  function extractTopSuggestionIds(suggestions, limit) {
    var ids = [];
    if (!Array.isArray(suggestions)) return ids;
    var sorted = suggestions.slice();
    sorted.sort(function (a, b) {
      var wa = SUGGESTION_SEVERITY_WEIGHT[a.severity] || 0;
      var wb = SUGGESTION_SEVERITY_WEIGHT[b.severity] || 0;
      if (wb !== wa) return wb - wa;
      if (a.id && b.id) {
        return a.id < b.id ? -1 : a.id > b.id ? 1 : 0;
      }
      return 0;
    });
    for (var i = 0; i < sorted.length && ids.length < (limit || 5); i++) {
      var suggestion = sorted[i];
      if (suggestion && suggestion.id && ids.indexOf(suggestion.id) === -1) {
        ids.push(suggestion.id);
      }
    }
    return ids;
  }

  function extractTopCategories(categorySummary, limit) {
    var categories = [];
    if (!Array.isArray(categorySummary)) return categories;
    for (var i = 0; i < categorySummary.length && categories.length < (limit || 3); i++) {
      var entry = categorySummary[i];
      if (entry && entry.category) {
        categories.push(entry.category);
      }
    }
    return categories;
  }

  function buildKeySignalsFromSuggestions(suggestions) {
    var signals = {};
    if (!Array.isArray(suggestions)) return signals;
    var counters = {
      missingMeta: 0,
      missingTitle: 0,
      missingH1: 0,
      multipleH1: 0,
      socialTags: 0,
      focusVisible: 0,
      missingAlt: 0,
      brokenLinks: 0
    };
    var keyboardTrap = false;
    var noindex = false;

    for (var i = 0; i < suggestions.length; i++) {
      var item = suggestions[i];
      if (!item || !item.id) continue;
      var id = item.id;
      switch (id) {
        case 'missing_meta_description':
          counters.missingMeta += 1;
          break;
        case 'missing_title':
          counters.missingTitle += 1;
          break;
        case 'missing_h1':
          counters.missingH1 += 1;
          break;
        case 'multiple_h1':
          counters.multipleH1 += 1;
          break;
        case 'social_tags':
          counters.socialTags += 1;
          break;
        case 'focus_visible':
          counters.focusVisible += 1;
          break;
        case 'broken_links':
          counters.brokenLinks += 1;
          break;
        case 'missing_alt_text':
        case 'a11y_missing_alt':
          counters.missingAlt += 1;
          break;
        case 'keyboard_trap':
          keyboardTrap = true;
          break;
        case 'noindex':
          noindex = true;
          break;
        default:
          break;
      }
    }

    if (counters.missingMeta) {
      signals.missingMetaDescriptionCount = counters.missingMeta;
    }
    if (counters.missingTitle) {
      signals.missingTitleCount = counters.missingTitle;
    }
    if (counters.missingH1) {
      signals.missingH1Count = counters.missingH1;
    }
    if (counters.multipleH1) {
      signals.multipleH1Count = counters.multipleH1;
    }
    if (counters.socialTags) {
      signals.socialTagsMissingCount = counters.socialTags;
    }
    if (counters.focusVisible) {
      signals.focusVisibleIssuesCount = counters.focusVisible;
    }
    if (counters.missingAlt) {
      signals.missingAltCount = counters.missingAlt;
    }
    if (counters.brokenLinks) {
      signals.brokenLinksCount = counters.brokenLinks;
      signals.brokenLinksDetected = true;
    }
    if (keyboardTrap) {
      signals.keyboardTrapDetected = true;
    }
    if (noindex) {
      signals.noindexDetected = true;
    }

    return signals;
  }

  var MEMORY_SIGNATURE_WINDOW_MS = 3000;

  var cavAIMemory = (function () {
    var cachedMemory = null;
    var lastSignature = { origin: '', signature: '', ts: 0 };

    function createEmptyMemory() {
      return {
        version: MEMORY_VERSION,
        updatedAt: Date.now(),
        byOrigin: {}
      };
    }

    function sanitizeMemory(memory) {
      if (!memory || typeof memory !== 'object') {
        return createEmptyMemory();
      }
      memory.byOrigin = memory.byOrigin || {};
      if (typeof memory.updatedAt !== 'number') {
        memory.updatedAt = Date.now();
      }
      if (typeof memory.version !== 'number') {
        memory.version = MEMORY_VERSION;
      }
      return memory;
    }

    function canPersistMemory() {
      if (typeof window === 'undefined' || !window.localStorage) {
        return false;
      }
      return !updatePrivacyState();
    }

    function readMemory() {
      if (cachedMemory) {
        return cachedMemory;
      }
      if (typeof window === 'undefined' || !window.localStorage) {
        cachedMemory = createEmptyMemory();
        return cachedMemory;
      }
      try {
        var raw = window.localStorage.getItem(MEMORY_STORAGE_KEY);
        var parsed = safeParseJSON(raw, null);
        cachedMemory = parsed && typeof parsed === 'object'
          ? sanitizeMemory(parsed)
          : createEmptyMemory();
      } catch (e) {
        cachedMemory = createEmptyMemory();
      }
      return cachedMemory;
    }

    function persistMemory(memory) {
      cachedMemory = memory;
      if (!canPersistMemory()) {
        return memory;
      }
      try {
        window.localStorage.setItem(MEMORY_STORAGE_KEY, JSON.stringify(memory));
      } catch (e) {
        // ignore storage failures
      }
      return memory;
    }

    function pruneOrigins(memory) {
      var keys = Object.keys(memory.byOrigin || {});
      if (keys.length <= MEMORY_MAX_ORIGINS) {
        return;
      }
      keys.sort(function (a, b) {
        var aTs = memory.byOrigin[a] && memory.byOrigin[a].lastSeenAt ? memory.byOrigin[a].lastSeenAt : 0;
        var bTs = memory.byOrigin[b] && memory.byOrigin[b].lastSeenAt ? memory.byOrigin[b].lastSeenAt : 0;
        return aTs - bTs;
      });
      while (keys.length > MEMORY_MAX_ORIGINS) {
        var remove = keys.shift();
        delete memory.byOrigin[remove];
      }
    }

    function buildRunEntry(summary, context, topIds, topCategories) {
      var scores = summary.scores || {};
      var severity = summary.severitySummary || {};
      var severityBy = severity.bySeverity || {};
      var run = {
        ts: Date.now(),
        pagesScanned:
          typeof context.pagesScanned === 'number' && context.pagesScanned >= 1
            ? context.pagesScanned
            : (typeof summary.pagesScanned === 'number' && summary.pagesScanned >= 1 ? summary.pagesScanned : 1),
        scores: {
          overall: typeof scores.overall === 'number' ? scores.overall : 0,
          seo: typeof scores.seo === 'number' ? scores.seo : 0,
          performance: typeof scores.performance === 'number' ? scores.performance : 0,
          accessibility: typeof scores.accessibility === 'number' ? scores.accessibility : 0,
          ux: typeof scores.ux === 'number' ? scores.ux : 0,
          engagement: typeof scores.engagement === 'number' ? scores.engagement : 0
        },
        severitySummary: {
          total: typeof severity.total === 'number' ? severity.total : 0,
          bySeverity: {
            critical: typeof severityBy.critical === 'number' ? severityBy.critical : 0,
            high: typeof severityBy.high === 'number' ? severityBy.high : 0,
            medium: typeof severityBy.medium === 'number' ? severityBy.medium : 0,
            low: typeof severityBy.low === 'number' ? severityBy.low : 0,
            note: typeof severityBy.note === 'number' ? severityBy.note : 0
          }
        },
        topSuggestionIds: topIds.slice(),
        topCategories: topCategories.slice(),
        keySignals: buildKeySignalsFromSuggestions(summary.suggestions),
        originContext: {
          path: context.path || '',
          planTier: context.planTier || null
        }
      };
      return run;
    }

    function buildStorageSignature(origin, summary, topIds) {
      var severity = summary.severitySummary || {};
      var total = typeof severity.total === 'number' ? severity.total : 0;
      var score = summary.scores && typeof summary.scores.overall === 'number'
        ? summary.scores.overall
        : 0;
      var ids = Array.isArray(topIds) ? topIds.join(',') : '';
      return origin + '|' + score + '|' + total + '|' + ids;
    }

    function recordFromSummary(opts) {
      opts = opts || {};
      var context = opts.context || {};
      var origin = typeof opts.origin === 'string' ? opts.origin : resolveOriginKey(context);
      var summary = opts.summary || {};
      var memory = readMemory();
      if (!origin) {
        return { memory: memory };
      }
      if (!canPersistMemory()) {
        return { memory: memory };
      }
      var topIds = extractTopSuggestionIds(summary.suggestions, 5);
      var categories = extractTopCategories(summary.categorySummary, 3);
      var signature = buildStorageSignature(origin, summary, topIds);
      var now = Date.now();
      if (
        lastSignature.origin === origin &&
        lastSignature.signature === signature &&
        now - lastSignature.ts < MEMORY_SIGNATURE_WINDOW_MS
      ) {
        return {
          memory: memory,
          run: memory.byOrigin[origin] &&
            memory.byOrigin[origin].runs &&
            memory.byOrigin[origin].runs[0]
        };
      }

      var originData = memory.byOrigin[origin] || { lastSeenAt: 0, runs: [] };
      var run = buildRunEntry(summary, context, topIds, categories);
      originData.runs = originData.runs || [];
      originData.runs.unshift(run);
      if (originData.runs.length > MEMORY_MAX_RUNS) {
        originData.runs.pop();
      }
      originData.lastSeenAt = now;
      memory.byOrigin[origin] = originData;
      memory.updatedAt = now;
      memory.version = MEMORY_VERSION;
      pruneOrigins(memory);
      persistMemory(memory);
      lastSignature = { origin: origin, signature: signature, ts: now };

      return { memory: memory, run: run };
    }

    function getLast(origin) {
      var key = typeof origin === 'string' ? origin : '';
      var memory = readMemory();
      var entry = memory.byOrigin[key];
      return entry && Array.isArray(entry.runs) ? entry.runs[0] : null;
    }

    function getDelta(origin) {
      var key = typeof origin === 'string' ? origin : '';
      var memory = readMemory();
      var entry = memory.byOrigin[key];
      if (!entry || !Array.isArray(entry.runs) || entry.runs.length < 2) {
        return null;
      }
      var current = entry.runs[0];
      var previous = entry.runs[1];
      var deltaScores = {};
      var pillars = ['overall', 'seo', 'performance', 'accessibility', 'ux', 'engagement'];
      for (var i = 0; i < pillars.length; i++) {
        var pillar = pillars[i];
        var currScore = current.scores && typeof current.scores[pillar] === 'number'
          ? current.scores[pillar]
          : 0;
        var prevScore = previous.scores && typeof previous.scores[pillar] === 'number'
          ? previous.scores[pillar]
          : 0;
        deltaScores[pillar] = Math.round(currScore - prevScore);
      }
      var deltaIssues = {
        total: current.severitySummary.total - previous.severitySummary.total
      };
      var severities = ['critical', 'high', 'medium', 'low', 'note'];
      for (var s = 0; s < severities.length; s++) {
        var severityKey = severities[s];
        var currCount = current.severitySummary.bySeverity[severityKey] || 0;
        var prevCount = previous.severitySummary.bySeverity[severityKey] || 0;
        deltaIssues[severityKey] = currCount - prevCount;
      }
      var summaryParts = [];
      if (deltaScores.overall !== 0) {
        summaryParts.push(
          'Overall score ' +
            (deltaScores.overall > 0 ? 'up ' : 'down ') +
            Math.abs(deltaScores.overall) +
            ' points'
        );
      }
      if (deltaIssues.high !== 0) {
        summaryParts.push(
          'High-impact items ' +
            (deltaIssues.high > 0 ? 'increased by ' : 'decreased by ') +
            Math.abs(deltaIssues.high)
        );
      }
      var deltaSummaryText = summaryParts.length
        ? summaryParts.join('; ') + '.'
        : 'No meaningful change versus the previous scan.';
      return {
        deltaScores: deltaScores,
        deltaIssues: deltaIssues,
        deltaSummaryText: deltaSummaryText
      };
    }

    function getTrend(origin) {
      var delta = getDelta(origin);
      if (!delta) {
        return {
          state: 'stagnating',
          reason: 'Not enough history to establish a trend yet.'
        };
      }
      var overall = delta.deltaScores.overall;
      if (overall > 1) {
        return {
          state: 'improving',
          reason: 'Overall score has been rising since the last scan.'
        };
      }
      if (overall < -1) {
        return {
          state: 'declining',
          reason: 'Overall score dropped compared to the previous scan.'
        };
      }
      return {
        state: 'stagnating',
        reason: 'Score movement is minimal, so the trend is steady.'
      };
    }

    function resetOrigin(origin) {
      var key = typeof origin === 'string' ? origin : '';
      var memory = readMemory();
      if (key && memory.byOrigin && memory.byOrigin[key]) {
        delete memory.byOrigin[key];
        memory.updatedAt = Date.now();
        persistMemory(memory);
      }
      return memory;
    }

    function writeMemory(next) {
      if (!next || typeof next !== 'object') {
        return readMemory();
      }
      next.byOrigin = next.byOrigin || {};
      next.updatedAt = Date.now();
      next.version = MEMORY_VERSION;
      pruneOrigins(next);
      return persistMemory(next);
    }

    return {
      read: readMemory,
      write: writeMemory,
      recordFromSummary: recordFromSummary,
      getLast: getLast,
      getDelta: getDelta,
      getTrend: getTrend,
      resetOrigin: resetOrigin
    };
  })();

  var cavAIIntel = (function () {
    var CONFIG_GLOBAL_IDS = {
      missing_viewport: true,
      missing_lang: true,
      missing_canonical: true,
      noindex: true
    };
    var CONFIDENCE_BASE_SCORE = 45;
    var CONFIDENCE_COVERAGE_WEIGHT = 35;
    var CONFIDENCE_RUN_WEIGHT = 5;
    var CONFIDENCE_REPEAT_WEIGHT = 6;
    var CONFIDENCE_CATEGORY_WEIGHT = 5;
    var DEFAULT_PAGE_CAP = 5;

    function getRunsForOrigin(memory, origin) {
      if (!origin || !memory || typeof memory !== 'object') {
        return [];
      }
      var entry = memory.byOrigin && memory.byOrigin[origin];
      if (!entry || !Array.isArray(entry.runs)) {
        return [];
      }
      return entry.runs;
    }

    function getRepeatDetails(summary, memory, origin) {
      var details = { count: 0, ids: [], categories: [] };
      if (!summary || !Array.isArray(summary.suggestions)) {
        return details;
      }
      var runs = getRunsForOrigin(memory, origin);
      if (runs.length < 2) {
        return details;
      }
      var previous = runs[1];
      if (!previous || !Array.isArray(previous.topSuggestionIds)) {
        return details;
      }
      var seenIds = {};
      var seenCategories = {};
      for (var i = 0; i < summary.suggestions.length; i++) {
        var suggestion = summary.suggestions[i];
        if (!suggestion || !suggestion.id) continue;
        if (previous.topSuggestionIds.indexOf(suggestion.id) === -1) continue;
        if (seenIds[suggestion.id]) continue;
        seenIds[suggestion.id] = true;
        details.ids.push(suggestion.id);
        details.count += 1;
        var category = suggestion.category || 'other';
        if (!seenCategories[category]) {
          seenCategories[category] = true;
          details.categories.push(category);
        }
      }
      return details;
    }

    function countConsecutiveRuns(id, runs) {
      if (!id || !Array.isArray(runs) || !runs.length) return 0;
      var consecutive = 0;
      for (var i = 0; i < runs.length; i++) {
        var run = runs[i];
        if (!run || !Array.isArray(run.topSuggestionIds)) {
          break;
        }
        if (run.topSuggestionIds.indexOf(id) !== -1) {
          consecutive += 1;
        } else {
          break;
        }
      }
      return consecutive;
    }

    function detectIntent(opts) {
      opts = opts || {};
      var origin = opts.origin || '';
      var memory = opts.memory || { byOrigin: {} };
      var state = intentCallState[origin] || { calls: 0, lastCallAt: 0 };
      var now = Date.now();
      var gap = state.lastCallAt ? now - state.lastCallAt : null;
      state.calls += 1;
      state.lastCallAt = now;
      intentCallState[origin] = state;

      var runs = (memory.byOrigin && memory.byOrigin[origin] && memory.byOrigin[origin].runs) || [];
      var runCount = runs.length;
      var intent = 'exploratory';
      var reason = 'Limited history suggests you are exploring this origin.';

      if (runCount <= 1 && state.calls <= 2) {
        intent = 'exploratory';
        reason = 'Early scans point toward familiarization.';
      } else if (gap !== null && gap > 24 * 60 * 60 * 1000) {
        var durationText;
        if (gap < 2 * 60 * 60 * 1000) {
          var minutes = Math.max(1, Math.round(gap / (60 * 1000)));
          durationText = minutes + ' minute' + (minutes === 1 ? '' : 's');
        } else if (gap < 48 * 60 * 60 * 1000) {
          var hours = Math.round(gap / (60 * 60 * 1000));
          durationText = hours + ' hour' + (hours === 1 ? '' : 's');
        } else {
          var days = Math.round(gap / (24 * 60 * 60 * 1000));
          durationText = days + ' day' + (days === 1 ? '' : 's');
        }
        intent = 'audit_mode';
        reason =
          'About ' + durationText + ' passed since the last scan; a great moment for an audit refresh.';
      } else if (gap !== null && gap < 5 * 60 * 1000) {
        intent = 'active_work';
        reason = 'Quick follow-up scans signal active troubleshooting.';
      } else if (runCount > 1) {
        intent = 'active_work';
        reason = 'Repeated scans show you are iterating on this origin.';
      }

      return { intent: intent, intentReason: reason };
    }

    function computeConfidence(opts) {
      opts = opts || {};
      var summary = opts.summary || {};
      var context = opts.context || {};
      var memory = opts.memory || { byOrigin: {} };
      var origin = opts.origin || '';
      var pagesScanned =
        typeof context.pagesScanned === 'number'
          ? context.pagesScanned
          : typeof summary.pagesScanned === 'number'
            ? summary.pagesScanned
            : 0;
      var pageLimit =
        typeof context.pageLimit === 'number' && context.pageLimit > 0
          ? context.pageLimit
          : DEFAULT_PAGE_CAP;
      var coverage = pagesScanned > 0
        ? Math.min(1, pagesScanned / Math.max(1, pageLimit))
        : 0;
      var runs = getRunsForOrigin(memory, origin);
      var runCount = runs.length;
      var repeatDetails = getRepeatDetails(summary, memory, origin);
      var categoryConsistency = repeatDetails.categories.length;
      var score = CONFIDENCE_BASE_SCORE;
      score += Math.round(coverage * CONFIDENCE_COVERAGE_WEIGHT);
      score += Math.min(20, runCount * CONFIDENCE_RUN_WEIGHT);
      score += Math.min(20, repeatDetails.count * CONFIDENCE_REPEAT_WEIGHT);
      score += Math.min(10, categoryConsistency * CONFIDENCE_CATEGORY_WEIGHT);
      if (score > 100) score = 100;
      if (score < 0) score = 0;
      var level = score >= 70 ? 'high' : score >= 45 ? 'medium' : 'low';

      var reasonParts = [];
      if (pagesScanned > 0) {
        var percent = Math.round(coverage * 100);
        reasonParts.push(
          'Coverage: ' +
            pagesScanned +
            ' page' +
            (pagesScanned === 1 ? '' : 's') +
            ' (' +
            percent +
            '% of cap)'
        );
      } else {
        reasonParts.push('Coverage signal is limited (no page count).');
      }
      if (runCount >= 2) {
        reasonParts.push('Seen across ' + runCount + ' scans.');
      } else {
        reasonParts.push(
          'History limited to ' +
            runCount +
            ' scan' +
            (runCount === 1 ? '' : 's') +
            '.'
        );
      }
      if (repeatDetails.count) {
        reasonParts.push(
          'Detected ' +
            repeatDetails.count +
            ' repeat issue' +
            (repeatDetails.count === 1 ? '' : 's') +
            '.'
        );
        if (categoryConsistency > 1) {
          reasonParts.push('Across ' + categoryConsistency + ' pillars.');
        }
      }
      var reason = reasonParts.filter(Boolean).join(' ');
      return { level: level, reason: reason };
    }

    function computeRisk(opts) {
      opts = opts || {};
      var summary = opts.summary || {};
      var severity = summary.severitySummary || {};
      var severityBy = severity.bySeverity || {};
      var keySignals = opts.keySignals || {};
      var overallScore =
        summary.scores && typeof summary.scores.overall === 'number'
          ? summary.scores.overall
          : null;
      var high = severityBy.high || 0;
      var critical = severityBy.critical || 0;
      var riskLevel = 'low';
      var brokenLinks = keySignals.brokenLinksCount || 0;

      if (critical > 0 || keySignals.noindexDetected || brokenLinks > 2) {
        riskLevel = 'high';
      } else if (
        high >= 2 ||
        (overallScore !== null && overallScore < 60) ||
        brokenLinks > 0
      ) {
        riskLevel = 'medium';
      }

      var reasons = [];
      if (critical > 0) {
        reasons.push(critical + ' critical item' + (critical === 1 ? '' : 's'));
      }
      if (high > 0) {
        reasons.push(high + ' high-severity item' + (high === 1 ? '' : 's'));
      }
      if (keySignals.noindexDetected) {
        reasons.push('page is set to noindex');
      }
      if (brokenLinks > 0) {
        reasons.push(
          brokenLinks + ' broken link' + (brokenLinks === 1 ? '' : 's')
        );
      }
      if (overallScore !== null) {
        reasons.push('overall score ' + overallScore + '/100');
      }
      var reason = reasons.slice(0, 3).join('; ');
      if (!reason) {
        reason = 'No high-impact signals detected yet.';
      }
      return { risk: riskLevel, riskReason: reason };
    }

    function countRepetition(summary, memory, origin) {
      var topIds = summary.topSuggestionIds || extractTopSuggestionIds(summary.suggestions, 3);
      if (!Array.isArray(topIds) || !topIds.length) {
        return 0;
      }
      var runs = (memory.byOrigin && memory.byOrigin[origin] && memory.byOrigin[origin].runs) || [];
      if (runs.length < 2) return 0;
      var previous = runs[1];
      if (!previous || !Array.isArray(previous.topSuggestionIds)) {
        return 0;
      }
      var count = 0;
      for (var i = 0; i < topIds.length; i++) {
        if (previous.topSuggestionIds.indexOf(topIds[i]) !== -1) {
          count += 1;
        }
      }
      return count;
    }

    function classifyFixReadiness(opts) {
      opts = opts || {};
      var suggestion = opts.suggestion || null;
      var origin = opts.origin || '';
      var memory = opts.memory || { byOrigin: {} };
      var context = opts.context || {};
      if (!suggestion || !suggestion.id) {
        return {
          readiness: 'content',
          why: 'This item lacks a stable identifier, so treat it as content-level.'
        };
      }
      var id = suggestion.id;
      var runs = getRunsForOrigin(memory, origin);
      var consecutive = countConsecutiveRuns(id, runs);
      var pagesScanned =
        typeof context.pagesScanned === 'number' ? context.pagesScanned : null;
      var pageLimit =
        typeof context.pageLimit === 'number' && context.pageLimit > 0
          ? context.pageLimit
          : null;
      var coveragePct = null;
      if (pagesScanned != null && pageLimit) {
        coveragePct = Math.min(1, pagesScanned / pageLimit);
      }
      if (coveragePct !== null && coveragePct >= 0.6) {
        return {
          readiness: 'config',
          why: 'Appears on about ' + Math.round(coveragePct * 100) + '% of the scanned pages.'
        };
      }
      var category = suggestion.category || '';
      var isGlobal = CONFIG_GLOBAL_IDS[id];
      if (isGlobal && consecutive >= 2 && (category === 'seo' || category === 'accessibility')) {
        return {
          readiness: 'config',
          why: 'Global metadata persisted across scans, so treat it as template-level config.'
        };
      }
      if (isGlobal && consecutive >= 2) {
        return {
          readiness: 'config',
          why: 'Global tag detected across multiple runs; this is a config-level signal.'
        };
      }
      if (consecutive >= 2) {
        return {
          readiness: 'template',
          why:
            'Detected in ' +
            consecutive +
            ' scans in the ' +
            (category || 'site') +
            ' pillar; likely template-level.'
        };
      }
      var historyNote =
        runs.length
          ? 'History: ' + runs.length + ' scan' + (runs.length === 1 ? '' : 's') + '.'
          : 'No prior scans yet.';
      return {
        readiness: 'content',
        why: 'Limited to this run; ' + historyNote
      };
    }

    function assessFatigue(origin, suggestions, memory) {
      var runs = (memory.byOrigin && memory.byOrigin[origin] && memory.byOrigin[origin].runs) || [];
      if (runs.length < 2) {
        return {
          persistedCount: 0,
          fatigueTone: 'none',
          fatigueMessage: 'Need at least two scans before we can surface persistent issues.'
        };
      }
      var persisted = [];
      var suggestionMap = {};
      for (var i = 0; i < suggestions.length; i++) {
        var item = suggestions[i];
        if (item && item.id) {
          suggestionMap[item.id] = item;
        }
      }
      var keys = Object.keys(suggestionMap);
      for (var k = 0; k < keys.length; k++) {
        var id = keys[k];
        var runsCount = countConsecutiveRuns(id, runs);
        if (runsCount >= 2) {
          persisted.push({
            id: id,
            runs: runsCount,
            severity: suggestionMap[id].severity || 'medium'
          });
        }
      }

      var persistedCount = persisted.length;
      var fatigueTone = 'none';
      var fatigueMessage = 'No persistent issues detected yet.';
      var hasFirm = persisted.some(function (item) {
        return item.runs >= 3 && (item.severity === 'high' || item.severity === 'critical');
      });
      if (hasFirm) {
        fatigueTone = 'firm';
        fatigueMessage = 'A high-impact issue has persisted for 3+ scans; escalate it to keep momentum.';
      } else if (persistedCount >= 2) {
        fatigueTone = 'nudge';
        fatigueMessage = 'Several issues are showing up repeatedly; resolve them to avoid fatigue.';
      } else if (persistedCount === 1) {
        fatigueTone = 'nudge';
        fatigueMessage = 'One issue has appeared in recent scans; tackling it now keeps the trend moving.';
      }

      return {
        persistedCount: persistedCount,
        fatigueTone: fatigueTone,
        fatigueMessage: fatigueMessage
      };
    }

    function buildInsightsViewModel(opts) {
      opts = opts || {};
      var pack = opts.pack || {};
      var origin = opts.origin || '';
      var scan = opts.scan || {};
      var memory = opts.memory || { byOrigin: {} };
      var keySignals = pack.keySignals || buildKeySignalsFromSuggestions(pack.suggestions || []);
      var scores = pack.scores || {};
      var severitySummary = pack.severitySummary || { total: 0, bySeverity: {} };
      var trend = (pack.intel && pack.intel.trend) || { state: 'stagnating', reason: '' };
      var confidenceLevel = (pack.intel && pack.intel.confidence) || 'medium';
      var riskLevel = (pack.intel && pack.intel.risk) || 'medium';
      var confidenceReason = (pack.intel && pack.intel.confidenceReason) || '';
      var riskReason = (pack.intel && pack.intel.riskReason) || '';
      var headerSubtitle = scan.pagesScanned
        ? 'Based on ' +
          scan.pagesScanned +
          ' deterministic page scan' +
          (scan.pagesScanned === 1 ? '' : 's')
        : 'Based on the latest snapshot';

      function capitalize(value) {
        return typeof value === 'string' && value.length
          ? value.charAt(0).toUpperCase() + value.slice(1)
          : '';
      }

      function toneForBadge(value, type) {
        if (type === 'confidence') {
          return value === 'high' ? 'good' : value === 'medium' ? 'caution' : 'alert';
        }
        if (type === 'risk') {
          return value === 'high' ? 'alert' : value === 'medium' ? 'caution' : 'good';
        }
        return 'neutral';
      }

      function toneForTrend(state) {
        if (state === 'improving') return 'good';
        if (state === 'declining') return 'alert';
        return 'neutral';
      }

      var badges = [
        {
          label: 'Confidence: ' + capitalize(confidenceLevel),
          tone: toneForBadge(confidenceLevel, 'confidence')
        },
        {
          label: 'Risk: ' + capitalize(riskLevel),
          tone: toneForBadge(riskLevel, 'risk')
        }
      ];
      if (trend && trend.state) {
        badges.push({
          label: 'Trend: ' + capitalize(trend.state),
          tone: toneForTrend(trend.state)
        });
      }

      var scoreCards = [];
      if (typeof scores.overall === 'number') {
        scoreCards.push({
          label: 'Overall health',
          value: scores.overall,
          detail: labelForScore(scores.overall)
        });
      }
      var pillarKeys = ['seo', 'performance', 'accessibility', 'ux', 'engagement'];
      for (var p = 0; p < pillarKeys.length; p++) {
        var pillarKey = pillarKeys[p];
        if (typeof scores[pillarKey] === 'number') {
          scoreCards.push({
            label: pillarKey.charAt(0).toUpperCase() + pillarKey.slice(1),
            value: scores[pillarKey],
            detail: labelForScore(scores[pillarKey])
          });
        }
      }

      var priorityList = [];
      var suggestions = pack.suggestions || [];
      for (var i = 0; i < Math.min(3, suggestions.length); i++) {
        var suggestion = suggestions[i];
        if (!suggestion) continue;
        priorityList.push({
          id: suggestion.id || null,
          title: suggestion.message || 'Untitled insight',
          severity: suggestion.severity || 'medium',
          metric: suggestion.metric || null,
          scoreImpact: typeof suggestion.scoreImpact === 'number' ? suggestion.scoreImpact : 0,
          category: suggestion.category || 'other'
        });
      }

      var nextActions = (pack.nextActions || []).map(function (action) {
        return {
          suggestionId: action.suggestionId,
          title: action.title,
          hint: action.hint,
          priority: action.priority,
          readiness: action.readiness,
          why: action.why
        };
      });

      var runs = getRunsForOrigin(memory, origin);
      var historyLinks = runs.slice(0, 3).map(function (run) {
        return {
          ts: run.ts || 0,
          label: run.ts ? 'Scan ' + new Date(run.ts).toISOString() : 'Previous scan',
          overall: run.scores && typeof run.scores.overall === 'number' ? run.scores.overall : null,
          issues:
            run.severitySummary && typeof run.severitySummary.total === 'number'
              ? run.severitySummary.total
              : 0
        };
      });

      var rationale = {
        coachMessage: pack.coachMessage || '',
        severitySummary: severitySummary,
        keySignals: keySignals,
        scanSummary: scan.summary || '',
        pagesScanned: scan.pagesScanned || null,
        pagesSelected: scan.pagesSelected || []
      };

      return {
        header: {
          title: origin ? 'Insights · ' + origin : 'CavAi Insights',
          subtitle: headerSubtitle
        },
        badges: badges,
        scoreCards: scoreCards,
        trendCard: {
          state: trend.state || 'stagnating',
          reason: trend.reason || 'Trend data is stabilizing.'
        },
        confidenceCard: {
          level: confidenceLevel,
          reason: confidenceReason || 'Available signals are limited.'
        },
        riskCard: {
          level: riskLevel,
          reason: riskReason || 'No high-impact signals detected.'
        },
        priorities: priorityList,
        nextActions: nextActions,
        rationale: rationale,
        historyLinks: historyLinks
      };
    }

    return {
      computeConfidence: computeConfidence,
      computeRisk: computeRisk,
      classifyFixReadiness: classifyFixReadiness,
      detectIntent: detectIntent,
      assessFatigue: assessFatigue,
      buildInsightsViewModel: buildInsightsViewModel
    };
  })();

  function isDebugModeEnabled() {
    if (typeof window === 'undefined') return false;
    try {
      if (window.localStorage && window.localStorage.getItem(DEBUG_STORAGE_KEY) === '1') {
        return true;
      }
      if (window.location && window.location.search) {
        var params = new URLSearchParams(window.location.search);
        if (params.get('cavaiDebug') === '1') {
          return true;
        }
      }
    } catch (e) {
      // ignore debug detection issues
    }
    return false;
  }

  var cavAI = {
    version: '1.x',
    build: {
      ts: '1.0',
      features: ['diagnostics', 'fixes', 'geo'],
      sdkVersion: '1.0.0'
    },
    status: buildCavAIStatus,
    configure: function (opts) {
      opts = opts || {};
      if (typeof opts.diagnosticsEndpoint === 'string') {
        cavAIConfig.diagnosticsEndpoint = opts.diagnosticsEndpoint;
      }
      if (typeof opts.fixEndpoint === 'string') {
        cavAIConfig.fixEndpoint = opts.fixEndpoint;
      }
      if (typeof opts.timeoutMs === 'number') {
        cavAIConfig.timeoutMs = opts.timeoutMs;
      }
      if (typeof opts.debounceMs === 'number') {
        cavAIConfig.debounceMs = opts.debounceMs;
      }
      if (typeof opts.geoTimeoutMs === 'number') {
        cavAIConfig.geoTimeoutMs = opts.geoTimeoutMs;
      }
      return cavAIConfig;
    },
  requestDiagnostics: function (opts) {
    var payload = opts || {};
    if (updatePrivacyState()) {
      emitEvent('diagnostics_failed', { reason: 'privacy_gate_active' });
      return Promise.resolve({ ok: false, reason: 'privacy_gate_active' });
    }
    var context = buildContextSnapshot();
    payload.context = payload.context || context;
    var originKey = resolveOriginKey(payload.context);
    var reservation = reserveSoftBurstSlot(originKey);
    if (!reservation.allowed) {
      emitEvent('diagnostics_rate_limited', {
        reason: 'soft_burst_control',
        origin: originKey
      });
      return Promise.resolve({
        ok: false,
        reason: 'soft_burst_control',
        message: SOFT_BURST_MESSAGE
      });
    }
    return scheduleDiagnosticsRequest(payload);
  },
    requestFixDiff: requestFixDiff,
    getSuggestionPack: function (snapshot, context) {
      var pack = buildSuggestionPack(snapshot, context);
      var ctx = context || buildContextSnapshot();
      var originKey = resolveOriginKey(ctx);
      var keySignals = pack.keySignals || buildKeySignalsFromSuggestions(pack.suggestions);
      var summaryForMemory = {
        scores: pack.scores,
        suggestions: pack.suggestions,
        severitySummary: pack.severitySummary,
        categorySummary: pack.categorySummary,
        pagesScanned: ctx.pagesScanned || 1,
        topSuggestionIds: extractTopSuggestionIds(pack.suggestions, 5),
        keySignals: keySignals
      };
      try {
        if (originKey && cavAI.memory && typeof cavAI.memory.recordFromSummary === 'function') {
          cavAI.memory.recordFromSummary({
            origin: originKey,
            summary: summaryForMemory,
            context: ctx
          });
        }
      } catch (err) {
        // ignore recorder errors
      }
      var memoryState = cavAI.memory.read();
      var confidence = cavAI.intel.computeConfidence({
        origin: originKey,
        summary: summaryForMemory,
        memory: memoryState,
        context: ctx
      });
      var risk = cavAI.intel.computeRisk({
        origin: originKey,
        summary: summaryForMemory,
        keySignals: keySignals
      });
      var delta = cavAI.memory.getDelta(originKey);
      var trend = cavAI.memory.getTrend(originKey);
      var fatigue = cavAI.intel.assessFatigue(originKey, pack.suggestions, memoryState);
      var intentInfo = cavAI.intel.detectIntent({
        origin: originKey,
        memory: memoryState,
        session: session
      });
      pack.nextActions = pack.nextActions.map(function (action) {
        var suggestion = null;
        for (var i = 0; i < pack.suggestions.length; i++) {
          var candidate = pack.suggestions[i];
          if (candidate && candidate.id === action.suggestionId) {
            suggestion = candidate;
            break;
          }
        }
        var classification = cavAI.intel.classifyFixReadiness({
          suggestion: suggestion,
          summary: pack,
          memory: memoryState,
          origin: originKey,
          context: ctx
        });
        return Object.assign({}, action, classification);
      });
      pack.intel = pack.intel || {};
      pack.intel.confidence = confidence.level;
      pack.intel.confidenceReason = confidence.reason;
      pack.intel.risk = risk.risk;
      pack.intel.riskReason = risk.riskReason;
      pack.intel.keySignals = keySignals;
      pack.intel.delta = delta;
      pack.intel.fatigue = fatigue;
      pack.intel.intent = intentInfo.intent;
      pack.intel.intentReason = intentInfo.intentReason;
      pack.intel.trend = trend;
      if (isDebugModeEnabled() && typeof window !== 'undefined' && window.console && typeof window.console.debug === 'function') {
        var debugPayload = {
          origin: originKey,
          confidence: pack.intel.confidence,
          delta: pack.intel.delta,
          fatigue: pack.intel.fatigue,
          intent: pack.intel.intent,
          memorySize: memoryState && memoryState.byOrigin
            ? Object.keys(memoryState.byOrigin).length
            : 0
        };
        window.console.debug('cavAI intel', debugPayload);
      }
      return pack;
    },
    getGeoSnapshot: function () {
      return Object.assign({}, coarseGeoSnapshot);
    },
    requestGeo: function (opts) {
      return requestGeoInternal(opts).then(function (result) {
        if (result.ok && result.geo) {
          coarseGeoSnapshot = {
            tz: coarseGeoSnapshot.tz,
            locale: coarseGeoSnapshot.locale,
            regionHint: result.geo.region || coarseGeoSnapshot.regionHint,
            updatedAt: Date.now()
          };
          if (typeof window !== 'undefined') {
            persistGeoSnapshot(coarseGeoSnapshot);
          }
        }
        return result;
      });
    },
    getContext: function () {
      return buildContextSnapshot();
    },
    on: onEvent,
    off: offEvent,
    emit: emitEvent
  };

  cavAI.memory = cavAIMemory;
  cavAI.intel = cavAIIntel;

  window.cavAI = window.cavAI || cavAI;
  window.cavAI.memory = window.cavAI.memory || cavAI.memory;
  window.cavAI.intel = window.cavAI.intel || cavAI.intel;
  window.cavai.requestDiagnostics = window.cavai.requestDiagnostics || window.cavAI.requestDiagnostics;
  window.cavai.requestFixDiff = window.cavai.requestFixDiff || window.cavAI.requestFixDiff;
  window.cavai.getSuggestionPack = window.cavai.getSuggestionPack || window.cavAI.getSuggestionPack;
  window.cavai.cavAI = window.cavAI;
  window.cavai.memory = window.cavai.memory || window.cavAI.memory;
  window.cavai.intel = window.cavai.intel || window.cavAI.intel;
 /* =========================================================
   CavAi — Eye Tracking (supports ALL CavBot heads)
   Targets:
   - Grid heads: .cavbot-eye-pupil inside .cavbot-eye-inner
   - DM avatar:  .cavbot-dm-eye-pupil inside .cavbot-dm-eye-inner
   ========================================================= */

 (function () {
   'use strict';

   // prevent double-binding if brain loads twice
   if (window.__cavbotEyeTrackingBound) return;
   window.__cavbotEyeTrackingBound = true;

   const MAX_PX = 5; // pupil travel
   const MAX_SHIFT_X = 3.2; // clamp horizontal travel so pupils stay inside bezel
   const MAX_SHIFT_Y = 2.6; // clamp vertical travel as well

  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

   function getPupilPairs() {
     const pupils = Array.from(
       document.querySelectorAll(
         // IMPORTANT: exclude pupils already managed by the head-tracking engine
         '.cavbot-eye-pupil:not([data-cavbot-pupil-managed]), .cavbot-dm-eye-pupil:not([data-cavbot-pupil-managed])'
       )
     );

     return pupils.map(p => {
       const inner =
         p.closest('.cavbot-eye-inner') ||
         p.closest('.cavbot-dm-eye-inner') ||
         p.parentElement;

       const cs = window.getComputedStyle(p);
       const baseTransform = (cs && cs.transform && cs.transform !== 'none') ? cs.transform : '';

       return inner ? { pupil: p, inner, baseTransform } : null;
     }).filter(Boolean);
   }

   function start() {
     let pairs = getPupilPairs();

     // If your page dynamically injects heads later, this keeps it resilient
    const refresh = () => {
      pairs = getPupilPairs();
      if (typeof window !== 'undefined') {
        window.__cavbotEyeTrackingLastRefresh = Date.now();
      }
    };

     let lastX = null, lastY = null, raf = null;

     // ===== ADDED: persist last pointer across navigations + seed on load (prevents static DM badge eyes) =====
     const LAST_POINTER_KEY = 'cavbotLastPointerV1';

     function readLastPointer() {
       try {
         const raw = window.sessionStorage && window.sessionStorage.getItem(LAST_POINTER_KEY);
         if (!raw) return null;
         const obj = JSON.parse(raw);
         if (!obj || typeof obj !== 'object') return null;
         const x = typeof obj.x === 'number' ? obj.x : null;
         const y = typeof obj.y === 'number' ? obj.y : null;
         if (x == null || y == null || !isFinite(x) || !isFinite(y)) return null;
         return { x, y };
       } catch (e) {
         return null;
       }
     }

     function writeLastPointer(x, y) {
       try {
         if (!window.sessionStorage) return;
         if (typeof x !== 'number' || typeof y !== 'number') return;
         if (!isFinite(x) || !isFinite(y)) return;
         window.sessionStorage.setItem(LAST_POINTER_KEY, JSON.stringify({ x: x, y: y, ts: Date.now() }));
       } catch (e) {
         // ignore
       }
     }

     function seedPointer() {
       const saved = readLastPointer();
       if (saved && typeof saved.x === 'number' && typeof saved.y === 'number') {
         queue(saved.x, saved.y);
         return;
       }
       // deterministic-ish, subtle offset (keeps badge eyes "alive" on first paint)
       const w = Math.max(window.innerWidth || 1, 1);
       const h = Math.max(window.innerHeight || 1, 1);
       const t = Date.now() % 1000;
       const ox = ((t / 1000) - 0.5) * 60; // -30..30 px
       const oy = (((1000 - t) / 1000) - 0.5) * 40; // -20..20 px
       queue(w * 0.55 + ox, h * 0.45 + oy);
     }
     // ================================================================================================

     function update() {
       raf = null;
       if (lastX == null || lastY == null) return;

       for (const { pupil, inner, baseTransform } of pairs) {
         const r = inner.getBoundingClientRect();
         const cx = r.left + r.width / 2;
         const cy = r.top + r.height / 2;

         const dx = lastX - cx;
         const dy = lastY - cy;

         const dist = Math.hypot(dx, dy) || 1;
         const nx = dx / dist;
         const ny = dy / dist;

         const amt = clamp(dist / 90, 0, 1) * MAX_PX;
         const shiftX = clamp(nx * amt, -MAX_SHIFT_X, MAX_SHIFT_X);
         const shiftY = clamp(ny * amt, -MAX_SHIFT_Y, MAX_SHIFT_Y);

         let t = `translate(${shiftX.toFixed(2)}px, ${shiftY.toFixed(2)}px)`;
         if (baseTransform) t += ` ${baseTransform}`;
         pupil.style.transform = t;
       }
     }

     function queue(x, y) {
       lastX = x; lastY = y;
       writeLastPointer(x, y);
       if (raf == null) raf = requestAnimationFrame(update);
     }

     // Primary pointer tracking
     window.addEventListener('pointermove', e => queue(e.clientX, e.clientY), { passive: true });
     window.addEventListener('mousemove',   e => queue(e.clientX, e.clientY), { passive: true });

     // Touch support
     window.addEventListener('touchmove', e => {
       const t = e.touches && e.touches[0];
       if (t) queue(t.clientX, t.clientY);
     }, { passive: true });

     // Reset on leave
     window.addEventListener('pointerleave', () => {
       lastX = lastY = null;
       for (const { pupil, baseTransform } of pairs) {
         pupil.style.transform = baseTransform ? baseTransform : 'translate(0,0)';
       }
     });

     // Optional: refresh pairs when user interacts (covers injected DOM)
     window.addEventListener('click', refresh, { passive: true });
     window.addEventListener('keydown', refresh, { passive: true });

     // ===== ADDED: auto-refresh on DOM changes / route changes (fixes DM badge pupils injected after load) =====
     let refreshScheduled = false;
     function scheduleRefresh() {
       if (refreshScheduled) return;
       refreshScheduled = true;
       requestAnimationFrame(() => {
         refreshScheduled = false;
         refresh();
       });
     }

     try {
       const mo = new MutationObserver(muts => {
         for (const m of muts) {
           if (!m || !m.addedNodes || !m.addedNodes.length) continue;
           for (const n of m.addedNodes) {
             if (!n || n.nodeType !== 1) continue;
             // Fast-path: if any injected node contains/IS a pupil/inner/head, refresh pairs
             if (
               (n.matches && (n.matches('.cavbot-eye-pupil, .cavbot-dm-eye-pupil, .cavbot-eye-inner, .cavbot-dm-eye-inner, [data-cavbot-head], .cavbot-dm-avatar'))) ||
               (n.querySelector && n.querySelector('.cavbot-eye-pupil, .cavbot-dm-eye-pupil, .cavbot-eye-inner, .cavbot-dm-eye-inner, [data-cavbot-head], .cavbot-dm-avatar'))
             ) {
               scheduleRefresh();
               return;
             }
           }
         }
       });
       mo.observe(document.documentElement || document.body, { childList: true, subtree: true });
     } catch (e) {
       // ignore
     }

     window.addEventListener('pageshow', () => { scheduleRefresh(); seedPointer(); }, { passive: true });
     window.addEventListener('popstate', () => { scheduleRefresh(); seedPointer(); }, { passive: true });
    window.addEventListener('hashchange', () => { scheduleRefresh(); seedPointer(); }, { passive: true });
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        scheduleRefresh();
        seedPointer();
      }
    }, { passive: true });
    // ================================================================================================

    if (typeof window !== 'undefined') {
      window.__cavbotEyeTrackingReady = true;
      window.__cavbotEyeTrackingLastRefresh = Date.now();
      window.__cavaiEyeTrackingRefresh = refresh;
    }

    // ===== ADDED: seed pointer on start so badge eyes are never static on initial paint =====
    seedPointer();
     // ====================================================================================
   }

   if (document.readyState === 'loading') {
     document.addEventListener('DOMContentLoaded', start, { once: true });
   } else {
     start();
   }
 })();
})();